[["index.html", "写给文科生的Python入门和数据处理教程 Python for Social Scientists 1 引言 1.1 本书目标 1.2 本书不足 1.3 使用的程序和版本 1.4 把Python安装到你的电脑里", " 写给文科生的Python入门和数据处理教程 Python for Social Scientists Li Weicheng @ gpnu 2021-10-24 1 引言 本文是Python入门和数据处理教程，基于经管类本科课堂教学用的讲义，以供同学们自学和参考。 p.s. 本文使用RStudio以及R的Bookdown包写成。 1.1 本书目标 负基础Python入门 对于首次接触编程的人，可能对计算机和操作系统的有关知识（如“命令行”，“路径”等）缺乏了解。本文尽量把有关的知识都介绍到，争取做到“会打字就能学Python”。 Python数据处理 基本目标：替代Excel 进阶目标：对科研常用数据，如Wind和CSMAR数据库、CFPS和CHIP等微观调查数据、统计局数据、oTree实验数据等，按照研究要求进行清洗、剪裁、整合以及绘图，为进一步分析（如回归）制作出合适的数据集。 金融数据分析 待定：视教学情况。 1.2 本书不足 由于课时非常紧张，有很多有意义的内容不得不舍弃，包括但不限于： 函数式编程和数据流思想 面向对象编程 单元测试 作者水平有限，很多内容未必是最优做法，只能争取尽量清晰和明确。 要顾及同学们的计算机基础有高有低，有些地方不得不写得比较啰嗦。 1.3 使用的程序和版本 使用Anaconda以及附带的Spyder作为主要的编程环境 Python版本3.6或以上。（涉及Type Hints和f-string等） 1.4 把Python安装到你的电脑里 要完成任何一个编程任务，首先要借助Python现有的巨大的程序库（一般可称为库Library，或者包Package）。本课程主要针对经济类数据分析，涉及的包比较多。为了避免逐个安装，我们采用比较简单的做法，直接安装Anaconda。这是一个所谓“Python发行版”，里面包含了Python的执行程序（解释器等），以及大量的科学计算用包。一般的数据分析工作，直接安装这个即可。 下载地址：https://www.anaconda.com/products/individual#Downloads 直接百度Anaconda也能找到这个链接。按照你自己的操作系统下载 ，一般选择最新版，现在的电脑一般选择64bit的安装文件，安装过程采用默认选项即可。 "],["python程序的执行.html", "2 Python程序的执行 2.1 一个Python程序是什么 2.2 Python的交互式环境 2.3 预备知识：路径 2.4 用Python解释器来运行", " 2 Python程序的执行 2.1 一个Python程序是什么 我们所谓“写一个Python”程序，到底是在写一个什么东西？ 一般情况下，所谓一个Python程序，仅仅是一个你电脑里的纯文本文件，但扩展名是*.py，这个文件本质上一个.txt文件没什么不同，都可以用任何文本编辑器（例如你电脑里的“记事本”）打开和编辑。 我们要做的工作，就是用一个文本编辑器（当然也可以是一个集成编程环境如后面会用到的Spyder），编辑一个.py文件，然后把你要的代码写进去，用不同的方法去执行这个文件里代码。可能是在系统里一次性执行整个文件里所有代码，也可能是在一个交互环境里一步一步地执行。 2.1.1 基础知识：扩展名和文件类型 用于表示某个文件是什么类型，一般我们会看文件名的最后一个英文.以及之后的内容。 注意：这里只是泛泛而论。扩展名也是可以修改的，所以未必和实际的文件类型一致。 一个文件，其名为WINWORD.EXE，其扩展名为.exe（Window系统的文件名不区分大小写，但Mac系统的文件名严格区分大小写），则意味着这是一个“Windows系统的可执行文件”。这实际上是微软Windows版本office中的Word的主程序。我们（在windows下）常说的“运行一个程序”，就是执行一个exe文件。 一个文件，其名为鲁迅全集.txt，其扩展名为.txt，则意味着这是一个“纯文本文件”，其中的所有内容都可以视为文字，可以用任何一个文本编辑器，例如记事本，或者Word打开。 其他扩展名，如.jpg是常见的图形文件，.docx是2007版本以后的Word文档，等等等等。 2.2 Python的交互式环境 我们先采用最基本的Python的交互式环境，给大家一点运行程序的感觉。 启动Anaconda Prompt。（用Mac的同学，启动终端terminal） 我们会看到命令行窗口 输入python &lt;回车&gt;，我们可以进入python的交互式运行环境。 注意： 其中的命令提示符&gt;&gt;&gt;。三个右侧尖括号，表示我们正处于python的交互式环境中，此时我们可以执行python的语句。 同时可见Python的版本为3.9.5，一般3.7.x以上皆可。 2.2.1 简单的编程：计算1 + 2 我们依次输入（每行代码以结束） &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = 2 &gt;&gt;&gt; c = a + b &gt;&gt;&gt; print(c) 显然，1+2必然得到 3 结果大致如图 注意： 无法得到结果3，首先检查有没有输入错误（打错字）。 print(c)中的小括号，是英文括号。在语法层面上的所有符号，都是英文符号。 如果输入的代码有误，已经敲了回车，只要把正确代码的再输入一次即可。 2.2.2 上述程序中涉及的一些概念 这个涉及程序设计的几个基本概念： 变量和赋值 变量，顾名思义，一个可变的量。编程中变量的概念和代数中的x, y, z基本一样。 Python中，对变量赋值使用1个等号 “=”。 显然， 我们有3个变量，a, b和c。我们把1赋予a，2赋予b，把a + b的值赋予c。 运算符 加减乘除，以及逻辑运算如是否等于，大于，小于等，我们以后会用到。这里只用到“加法” 函数 和数学函数一样，我们调用一个函数，给这个函数传递一个参数，然后这个函数会根据这个参数做一些事情。可能是为你进行一个计算，可能修改某个变量等等，也可能什么都不做。 这里我们调用的函数是print()，这个函数的用途是把你传递给他的变量c的值打印出来。函数的调用方法是函数名与小括号。 数据分析的程序，大部分情况下可以视为由变量和函数组成。 2.2.3 退出运行环境 输入exit()，然后回车即可。 可见，exit本身也是一个函数（函数名+小括号），其调用这个函数的作用是退出Python交互式运行环境。 注意：一定要退出，以便后续的程序能执行。 此时，我们又回到了一开始的命令行（终端）环境中 可见，命令提示符现在是一个&gt;，这提示我们正处于系统的命令行环境中 可以执行系统中的命令，但不能执行python中的语句！ 要进行交互式的python编程，要首先进入Python的交互式环境中！ 2.3 预备知识：路径 2.3.1 路径Path 你的文件或者文件夹（目录），到底保存到了哪里？ 所谓路径(path)，到达某个文件或者文件夹（目录）的层级结构，每一层用一个斜杠“/”分割。 在命令行（终端）环境下，在命令提示符&gt;之前，一般会有提示你当前路径，即当前你处于哪个目录下。 例如 C:\\Users\\lee，指的就是，在你的C盘下，Users目录下，的lee目录。 注意：在你的电脑上，这里的lee会替换为你的用户名 这样，你输入的任何命令，都会对“当前路径”生效。 同样，路径既可以指向一个目录（文件夹），也可以指向一个文件。 如C:\\Users\\lee\\add.py，就指的是，在你的C盘下的Users目录下的lee目录下的一个叫add.py的文件。 2.3.2 相对路径和绝对路径 绝对路径：从根目录（windows下即一个盘符，如c盘或者d盘）开始的路径，可以确定无疑地指向某个文件或者目录。如C:\\Users\\lee\\add.py。 相对路径：不从根目录起始的路径。其指向的目的地，从你的“当前路径”开始，往下数。 假如，你的当前路径是C:\\Users，那么此时，相对路径lee\\add.py，所指向的，就是当前路径下（C:\\Users），lee目录下的add.py。这也等价于绝对路径C:\\Users\\lee\\add.py。 两者的区别：绝对路径从根目录开始，相对路径从“当前路径”开始。 2.3.3 进入某个目录 Windows命令行，和Mac的终端，有相同的命令cd &lt;路径&gt;，可以进入一个目录。 如，在终端中输入（并回车）注意这里使用的是绝对路径 cd C:/Users 则会让终端进入到 C:/Users 目录下。见提示符&gt;前方的“当前路径”已经改变为C:/Users。你现在已经位于C:/Users 目录。 尝试相对路径，在终端中输入（并回车），注意这里的lee，请替换成你的用户名。 cd lee 则会让终端进入到 C:/Users/lee 目录下。见提示符&gt;前方的“当前路径”已经改变为C:/Users/lee。你现在已经位于C:/Users/lee 目录。 其他用法包括： 进入上一级目录 cd .. 进入根目录 cd / 可以让你在命令行和终端中，定位到你想要的目录和文件。 2.3.4 用Windows图形界面获得路径 在你的windows资源管理器（俗称“我的电脑”），在任何一个文件夹中，点击地址栏 你就可以得到这个文件夹的路径，可以粘贴到命令行中。 特别注意：正反斜杠问题 在编程的语境下，反斜杠“\\”有特殊用途。因此，表示路径的时候，我们统一用（正）斜杠“/”，而不用反斜杠“\\”。 统一的写法，如C:/Users/lee 2.3.5 列目录 列目录的命令，Windows的命令行中为dir，Mac中为ls。同学们可以执行尝试。 2.4 用Python解释器来运行 当你离开交互环境，你的程序就没了。当然，我们不可能每次都把程序从头写一次。如前文所述，我们编写一个.py文件来保存我们的代码，然后利用系统中安装的Python解释器来执行它。 2.4.1 编写源代码 前面说过，python的代码文件.py是一个和.txt同样的纯文本文件，所以我们这次直接用记事本来编辑。 打开windows的记事本，把刚才的1 + 2程序写进去，按ctrl+s保存 a = 1 b = 2 c = a + b print(c) 在C盘根目录下，建立一个新的文件夹，例如“PythonClass”。 类型选择.（所有文件），文件名可以任意起，但是必须以.py结尾。例如我这里采用add.py。 保存。 注意： 如果你按此操作，那么你的PythonClass文件夹的完整路径（绝对路径）就是C:/PythonClass。而你的.py文件的完整路径，就是C:/PythonClass/add.py 如果你自行选取其他位置保存.py文件，那么路径也可以如此类推。如果实在找不到，则可见在Windows图形界面获得路径。 2.4.2 执行这个代码 确保你刚才已经退出了Python的交互环境。我们现在首先要定位到我们保存.py文件的目录，如果大家按操作运行，这个文件应该在C:/PythonClass目录下。 我们cd命令，转移到我们保存py文件的路径： 输入 (并回车) cd C:/PythonClass 此时你的命令提示符应该告诉你，现在位于C:/PythonClass目录下。 C:\\PythonClass&gt;_ 输入（并回车） python add.py 这句命令的含义是：让系统中装好的python解释器，去运行add.py这个python脚本文件。这个脚本文件就在当前目录中（或者环境变量path中的目录，现在可以忽略这一点）。 实际上，我们以用绝对路径来指向add.py，也是一样的。 python C:/PythonClass/add.py 如果一切顺利，你将会看到结果 3 而不同之处在于，我们的程序这次保留了下来，我们要继续上一次编程，我们只要打开这个py文件，继续往里写代码即可。 那如果我们既要保存代码，又要一边执行代码、一边看结果怎么办？ "],["使用spyder编程环境.html", "3 使用Spyder编程环境 3.1 界面 3.2 在Spyder中写代码 3.3 运行程序 3.4 预备知识：Python的注释（comment） 3.5 运行程序（续） 3.6 确定一个项目文件夹", " 3 使用Spyder编程环境 实际上，我们真正用python做数据分析的时候，一般会利用一个集成编程环境，例如我们本课程要用的Spyder，或者流行的PyCharm，或者jupyter notebook等等。 这些集成编辑环境，通常会把.py文件的编辑和python的交互环境结合起来，让我们一边编辑py文件的同时，一边执行代码并查看结果。数据分析完毕时，代码同时也写成了。 3.1 界面 打开Spyder Spyder默认打开了一个临时的.py文件。 左边是一个文本编辑器（回忆前面我们编辑add.py文件所用的记事本）。 文本编辑器的标签页，显示我们当前打开的文件是temp.py。如果文件名后带*号，表示这个文件修改了但尚未保存。 标签页上方，显示了当前文件temp.py的路径。显然，这是一个绝对路径，显示了从根目录开始到这个文件的完整路径。 右下角是Python的交互运行环境。这个环境叫IPython，比我们刚才运行Python交互环境要稍微先进一点，但本质上并无不同。 工具栏，我们后面再说。 3.2 在Spyder中写代码 我们在左侧的文本编辑器，把刚才的1+2程序写进去，按Ctrl+s保存一下（Mac: Cmd + s）。 3.3 运行程序 3.3.1 从头到尾运行代码 点击工具栏的运行按钮（Run File），或者按键盘的F5，我们可以把当前的.py脚本从头到尾运行一遍。 看交互式窗口，得到结果为3。 Run File，这个按钮的功能约等于我们在命令行环境下，直接运行“Python temp.py”。(注意我们正在编辑的文件是temp.py) 3.3.2 变量监视器 点击右上角一栏的Variable Explorer（变量浏览器），可以看到当前运行环境中的所有变量和他们的类型以及值（变量类型见后）。 点击交互界面上方的垃圾桶图标Remove all variables（移除所有变量），点击yes。 3.3.3 单步执行 现在找到“Run selection or current line”按钮。 这个按钮，顾名思义。如果你选择了一部分代码则，执行这部分代码。如果你没有选择代码，则执行光标所在行。执行完毕后，光标会自动移动到下一行。 让我们试一下。 点击第一行a=1，让输入光标在这一行 点击 ，或者F9 我们可以看到，这个按钮把光标所在行的代码“a = 1”，发送到了交互窗口，并执行，且光标自动下移了一行。 右上方的变量浏览器，现在自动出现了变量a 显然，如果我们连续点击，或者连按F9，我们就可以连续地、单步执行代码。每按一次，Spyder会把当前行的代码（或者你选定的代码），发送到交互窗口并执行。 打一个比方，这就像你同时打开记事本和python交互环境，一边在记事本中写代码，一边手动地拷贝粘贴到python交互环境中执行，是同样的逻辑。 这使得我们可以逐步查看每一行代码的效果，是实际工作中的常规操作之一。 3.3.4 选择执行 这个按钮也可以一次性执行你所选择的代码，这个大家可以自行尝试。 3.4 预备知识：Python的注释（comment） 先说注释。Python使用井号：#来表示注释。所谓注释，就是“给人看”的内容，而Python的解释器会直接忽略掉这部分。 注释可以出现在任何地方，注意#号只会影响同一行右边的代码，因此也可以出现在行尾。 注释往往也可以用来临时屏蔽一部分代码，只要在代码的最左侧插入一个#，那么整行代码会被Python解释器忽略。这是常用技巧。 我们尝试写几个注释，例如： 注释是对代码的说明，非常重要： 写代码时间长了，肯定会不记得自己写的内容。有时候上午写的，下午就会忘记。 多人合作的时候，要读懂彼此的代码，也必须有良好的注释。 特别地，注释是考试的给分点。你的考试程序输出了正确的结果，可以得到合格评价，同时具有良好的编写风格、合理的注释，才能得到更高分。 3.5 运行程序（续） 3.5.1 按Cell（单元格）执行 一般我们的程序，往往有一长串代码，或者连续几条语句，只是为了达到某一个特定目的。如果我们修改了某些代码，希望把整个代码块一次执行完，直接查看阶段性的结果，就可以使用cell。 可以使用特殊的注释#%%，两个#%%中间的代码，会被Spyder认为是一个cell（单元格）。光标所在的cell，会有不同颜色的背景颜色来区分。 定义好cell之后，我们可以使用工具栏中的2个按钮 第一个按钮是“Run current cell：执行这个cell”，快捷键是Ctrl + 回车。 第二个按钮是“Run current cell and go to the next one：执行这个cell，且光标移动到下一个cell”，快捷键是Shift + 回车。 按cell执行，和前述的按行执行，是我们做数据分析的时候会反复使用的按钮。 我们先新建一个“赋值的cell”，和“计算并打印的cell”，们用垃圾桶图标，先清空所有变量。 执行第一个cell，可以发现，变量a和b同时出现在变量浏览器中。这意味着这个cell内的按钮被一次性执行了。 当我们只关心一大块代码的结果，但不是太关心过程，我们就可以把这块代码划分为一个cell，随后就可以整块整块地执行。 3.5.2 显示你要的结果 使用交互窗口： 1. 我们之间在交互窗口输入这个变量名a，回车 2. 我们之间在交互窗口输入一个打印语句print(a)，回车 两者基本一样，但某些情况print可以接收参数，改变打印行为（样式等），直接输入变量名，就只能用默认的形式输出。 使用编辑器 1. 逐行执行，单独一个变量名也可以显示 2. 按cell运行，只会显示print()的结果 一般而言，使用print()，在代码中会比较“显眼”，达到顾名思义的效果，尽量使用。而如果只是想临时看一下变量的值，直接在交互窗口输入也可以。 3.6 确定一个项目文件夹 以C:/PythonClass为例。课程所有的有关文件，都会保存在这个目录下。我们称之为“工作目录Working Directory”。 也可以把工作目录建立在你习惯的位置。 为一个特定的工作建立一个特定的目录，是一个良好的习惯。 3.6.1 在Spyder中设定这个目录为工作目录 点击界面右上角的“browse a working directory”按钮，选择你刚才建立的工作目录。（本例中为C:/PythonClass） 切换到Files标签栏 把我们正在编辑的py文件，另存为到工作目录，命名为add.py。这样，在文件列表，我们会看到这个文件 注意：如果前面大家按步骤做，这里应该会覆盖掉上一节课的同名文件。 "],["变量和常用类型.html", "4 变量和常用类型 4.1 变量 4.2 数值 4.3 字符串String 4.4 布尔型Boolean 4.5 None类型 4.6 简单类型转换 4.7 Python的类型转换和类型错误", " 4 变量和常用类型 4.1 变量 前面说过，Python（或者其他编程语言）中的变量，和你数学课上的x, y, z是同类的概念。 正如前面的例子，Python使用等号=来为一个变量赋值 #%% 赋值与重新赋值 a = 1 a = 2 print(a) 假如这个一开始不存在，那么赋值的同时，也会把这个变量创造出来。 对于Python语言，这个过程（不严格地说）大致是： （绑定）Python在电脑的内存空间找了一个空地，创建了一个对象(object)，存放了1这个值，然后把a这个名字，和这个对象绑定起来。 （重绑定）当我们对变量a赋其他值的时候，如a = 2的时候，Python另外创建了一个对象，存放了2这个值，然后把a这个名字，重新绑定到这个新的对象上。 （引用）变量名，就像一个内存中的对象的标签。引用这个名字，就是引用其表示的对象。 4.1.1 删除一个变量 使用del语句 #%% 删除变量 a = 1 del a print(a) 因为变量a已经被我们删除了，所以你再次引用a的时候，Python会告诉你, NameError: name &#39;a&#39; is not defined 4.1.2 动态语言 Python是一个“动态语言”，即Python的变量的类型是在运行过程中决定，或者说可以在运行中改变：你对这个变量赋什么值，这个变量就是什么类型。 查看变量类型的函数是type() 例如 #%% 动态类型 a = 1 print(type(a)) a = &#39;apple&#39; # 这里为a赋值了一个字符串 print(type(a)) &lt;class &#39;int&#39;&gt; &lt;class &#39;str&#39;&gt; 显然，a先是一个整型int&lt;class 'int'&gt;，然后变成了一个字符串str&lt;class 'str'&gt;。 这和我们的赋值顺序是一样的。类型后面会详细说 注意：Python的变量类型是动态确定的。变量的类型不一定能从名字看出来，这是出错的一大来源。 4.1.3 变量的命名规则 4.2 数值 Python 3.x以后，数值类型有2种，整型int，和浮点型float。 顾名思义，整型可以理解为整数： #%% 整型 a = 1 print(type(a)) ## &lt;class &#39;int&#39;&gt; 而浮点型则可以理解为小数： #%% 浮点型 a = 1.23 print(type(a)) ## &lt;class &#39;float&#39;&gt; 特别地，a = 1.0是什么类型？ a = 1.0 print(type(a)) ## &lt;class &#39;float&#39;&gt; 显然，a是浮点型：只要你赋值的时候有小数点。 这可能是因为： 这个变量客观上是个小数，只是“恰好”是1而已。 或者这个数被四舍五入，比如本来是1.0000001之类。 4.2.1 数值的操作 常见的操作包括加减乘除+, -, *, /，此处不再重复。 特别地，除法永远返回浮点类型： a = 4 / 2 print(a) ## 2.0 print(type(a)) ## &lt;class &#39;float&#39;&gt; 整除是//。若除数是整型，则返回整型；若除数是浮点型，则返回浮点型 5 // 2 ## 2 5 // 2.0 ## 2.0 取余% 5 % 2 ## 1 乘方 \\(2^3\\) 2 ** 3 ## 8 4.3 字符串String 创建字符串，可以使用单引号、双引号、三单引号和三双引号。其中三引号可以多行定义字符串。 字符串：可以使用单引号、双引号 #%% 字符串 a = &#39;apple&#39; # 或者：a = &quot;apple&quot; print(a) ## apple 多行字符串：可以使用三个单引号，或者三个双引号。 a = &#39;&#39;&#39;Hello Python &#39;&#39;&#39; print(a) Hello Python 4.3.1 字符串的常用操作 连接字符串 + a = &#39;Hello&#39; b = &#39;Python&#39; print(a + b) ## HelloPython 注：可以连加：a + b + c + d 其他常用操作 a = &#39;Hello Python&#39; print(&#39;lo&#39; in a) # in： 是否存在 ## True print(a.find(&#39;th&#39;) )# find()：查找位置 ## 8 print(a.replace(&#39;Python&#39;,&#39;Bob&#39;)) # replace()：替换 ## Hello Bob print(a.lower()) # 转为小写：lower() ## hello python print(a.upper()) # 转为大写：upper() ## HELLO PYTHON print(&quot; apple pie &quot;.strip()) # 去除头尾的不可见字符（包括空格） ## apple pie 切片：截取字符串的一部分 后面讲列表List会详细介绍 4.3.2 显示特殊字符：转义字符\\ (转义字符到本章最后：2课时) “换行\\n” print(&quot;Hello\\nPython&quot;) ## Hello ## Python 显示反斜杠、单引号、双引号等等 这些字符，本身已经是Python语法的一部分，要放在字符串中显示，需要转义，即在这个符号之前加反斜杠，如你要显示双引号，则可以使用\\\"。 print(&#39;反斜杠\\\\&#39;) # 反斜杠 \\\\ ## 反斜杠\\ print(&#39;\\&quot;双引号\\&quot;&#39;) # 双引号 \\&#39; ## &quot;双引号&quot; print(&#39;\\&#39;单引号\\&#39;&#39;) # 单引号 \\&quot; ## &#39;单引号&#39; 如果一下子看不清楚，应该如何书写： 作为字符串最外侧的单引号，或者双引号，必须对称 a = &#39; &#39; 在单引号，或者双引号内，写入你要的文字 a = &#39;HelloWorld&#39; 把转义字符看成一个整体，插入其中，如\\n a = &#39;Hello\\nWorld&#39; print(a) ## Hello ## World 插入斜杠等，也是一样 4.3.3 字符串格式化 我们往往需要把一个变量插入一行字符中，例如我们想显示变量a和b的值 #%% 简单加法 a = 1 b = 2 c = a + b print(a) print(b) print(c) 会得到： 1 2 3 但问题是，你只看结果，其实分不清哪个是a，哪个是b，哪个是c。所以，我们更想要的是一句话，如 a的值是: 1 b的值是: 2 c的值是: 3 所以要用到字符串格式化，把变量和字符串混合。 print(&#39;a的值是:{}\\nb的值是:{}&#39;.format(a,b)) ## a的值是:1 ## b的值是:2 解释一下： 首先,'a的值是:{}\\nb的值是:{}'，是一个字符串对象（object），注意两边的单引号。 Str.format()，是字符串类型的一个方法（method），也可以称之为“成员函数”：函数名+小括号。 一个对象的方法，粗略地理解是：someone.do_something()，某样东西做了一件什么事。 Str.format()，这个方法即一个“字符串格式化了自己”。具体的做法，是把format()的参数，这里是a和b，按顺序填进原字符串中的大括号{}中。 5.注意，我们使用了换行符\\n 实际上，把字符串对象赋值给变量，如msg，那么msg就成了字符串类型（或者说指向了一个字符串对象），所以也可以这么做： msg = &#39;a的值是:{}\\nb的值是:{}&#39; print(msg.format(a,b)) ## a的值是:1 ## b的值是:2 还可以按参数的顺序（第一个元素是0）： msg = &#39;c的值是:{2}\\na的值是:{0}\\nb的值是:{1}&#39; print(msg.format(a,b,c)) ## c的值是:3 ## a的值是:1 ## b的值是:2 还有更简洁的办法”f-string”：需要python3.6版本或以上 变量的开头（单引号或者双引号之前），加f，形成f''，即所谓”f-string”。 这种字符串在打印的时候，python会自动把对应的变量填充进去。 在中括号里直接填变量名 msg = f&#39;a的值是:{a}\\nb的值是:{b}&#39; print(msg) ## a的值是:1 ## b的值是:2 实际上，你要在中括号里放其他python语句，例如其中做运算，也可以 msg = f&#39;a + b的值是{a + b}&#39; print(msg) ## a + b的值是3 简单的格式化：变量后加{变量名:格式} 如只显示2位小数:0.2f pi = 3.1415926535897 print(f&quot;圆周率（保留2位小数）是{pi:0.2f}&quot;) ## 圆周率（保留2位小数）是3.14 如以百分数形式显示:%，保留2位小数是:.2% z = 0.25 print(f&quot;z是{z:.2%}&quot;) ## z是25.00% 其他格式，可以问百度和谷歌，我们后面遇到也会讲。 4.4 布尔型Boolean 布尔型Boolean，也常简称为bool，逻辑关系，只有2个值：真True，或者假False（注意区分大小写） 一般用于条件判断（详细见后） a = 1 b = 2 if a &gt; b: print(&quot;a is bigger&quot;) 4.4.1 简单布尔运算 对于不熟悉编程的同学可能有点抽象。 与 and，或or，非not 与 and，简称：“所有条件同时成立”（全部条件为True，会得到True；否则为False） 如：“学号是单数”，且“坐在班级前排的同学” print(True and True) ## True print(False and True) ## False print(False and False) ## False 或or，简称：“最少有一个条件成立”（最少一个条件为True，会得到True；全部条件为False，则得到False） print(True or True) ## True print(False or True) ## True print(False or False) ## False 非not：取反 print(not True) ## False print(not False) ## True 举例： a = 1 b = 2 a &gt; b ## False (a &gt; 1) and (b &gt; 1) ## False (a &gt; 1) or (b &gt; 1) ## True not (b &lt; 2) ## True 注意：重点强调，必须留意运算符的优先级，先运算的部分要加括号！这和小学的数学运算是一样的。 4.5 None类型 空值，一切皆非。粗略地可以理解为一个“占位符”，例如一个不返回任何值的函数，以后遇到会再解释。 a = None print(a) ## None 4.6 简单类型转换 字符串和数值 字符串：可以表示词语、句子，可以拼接，组合 数字：可以运算 数字可以拼接吗？字符串可以做运算吗？ 先转换一下类型 birth = &quot;2001&quot; age = 2021 - birth print(age) TypeError: unsupported operand type(s) for -: &#39;int&#39; and &#39;str&#39; NameError: name &#39;age&#39; is not defined 一般而言，类型转换的函数，就是目标类型的名字。 把某个变量（如字符串str）转整型int，用函数int()，转为浮点是float() birth = &quot;2001&quot; age = 2021 - int(birth) print(age) ## 20 age = 2021 - float(birth) print(age) ## 20.0 显然反过来转换也是可以的，把某个变量转为字符串str() print(&#39;Your age is &#39; + str(age)) ## Your age is 20.0 布尔型 （有逻辑学基础，可以快速过） 特别地，布尔型中，True可视为1，False可视为0。 因此我们可以把数字的运算套用在布尔型上。 注意：要保持代码的清晰性，一般不建议使用布尔型进行运算，除非你很明白自己在做什么。 a = True # True可视为1 print(a + 1) ## 2 b = False # False可视为0 print(b - 1) ## -1 做条件判断的时候，0会判定为False，非0会判断为True，这个我们后面说条件语句的时候会说。 if -1: print(&#39;hello&#39;) ## hello 4.7 Python的类型转换和类型错误 Python是一个“动态类型+强类型”语言 动态类型： 变量名运行时绑定，变量名只是一个可以撕掉和重新粘贴的标签。你为某个变赋值什么类型，这个变量就是什么类型，在运行时可以随你的赋值代码而改变。 强类型： 一般情况下，Python不会为你自动转换类型（不会“隐式类型转换”）。 如一个很热门的语言JavaScript，大家现在上网看到的多数网站，其页面都是js语言写的。 在js中，一个字符”0”加一个数字1，js会自动（隐式地）把后者转换为字符串，然后进行拼接。 &quot;0&quot; + 1; // &quot;01&quot; 这其实对你的代码质量（如类型的检验）提出了更高要求，比如你的本意可能是要2个数字相加。 但这段代码会在你毫无知觉的情况下，一直运行下去，导致你可能要在无数代码执行过后，才发现问题。 在Python中，则会报错TypeError错误。 &#39;0&#39; + 1 TypeError: must be str, not int 显然，这说的是一个str，只能和另一个str相加（串联），而不能是一个int。 这个时候你应该用“显式”的类型转换。 如果看到TypeError，检查你的变量类型。 "],["常用数据结构.html", "5 常用数据结构 5.1 列表List 5.2 元组Tuple 5.3 字典Dict", " 5 常用数据结构 数据结构：是计算机中存储、组织数据的方式。（几乎是废话） 例如“新华字典”： 数据就是每一个字的解释 组织方式是按拼音，顺序排列 一个索引（目录），以供你查找数据。 Python中的Dict与之类似，后面详细解释。 5.1 列表List 一个列表List，就是把几个元素(items)，用一个固定的顺序连在一起的数据结构。列表List是一个重点，超级常用，内容比较多。 5.1.1 列表的创建 创建一个列表，可以用中括号[]，其中每一个元素用逗号分开。 为了好看，建议每个逗号后加一个空格。 #%% 列表List numbers = [1, 2, 3, 4, 5, 6] letters = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] print(numbers) ## [1, 2, 3, 4, 5, 6] print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 列表中的元素，可以混合多种类型。但一般不建议这么做。 a_list = [1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] print(a_list) ## [1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 我们还可以创建空List。比如，当列表的第一个元素还没确定，而你要先行创建列表，然后再生成元素添加进去。 #%% 空列表 empty_list = [] empty_list = list() print(empty_list) ## [] 对一个字符串String 使用list()函数，可以把字符串分解成字母组成的List。这本质上就是类型转换：用类型的名字做转换函数的名字。 如果把函数名list看成是一个动词，或者可以解释成：list a string。 #%% print(list(&#39;apple&#39;)) ## [&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] 注意：实际上，list()可以用于所有类型的序列（有序列结构的其他数据），以后我们遇到回说。 特别地，如果我们转换一个多行的字符串，会发现什么？ a = &#39;&#39;&#39;hello python &#39;&#39;&#39; print(list(a)) ## [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\\n&#39;, &#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;, &#39;\\n&#39;] 注意，换行符\\n也出现在其中。实际上，应该把换行符之类的不可见字符也看成一个真正的字符，实际上存在，但部分情况不可见而已 5.1.2 列表的元素 要引用一个列表的元素，也使用[]，其中包括元素的索引(index)，注意第一个元素的索引是0（Python和c语言一样，从0开始计数） print(numbers) ## [1, 2, 3, 4, 5, 6] print(numbers[0]) ## 1 print(numbers[3]) ## 4 可以反向引用元素，例如-1指向最后一个元素，-2指向倒数第二个，如此类推 print(numbers) ## [1, 2, 3, 4, 5, 6] print(numbers[-1]) ## 6 print(numbers[-2]) ## 5 列表中的元素是可变的。同样，用等号=对某个元素赋值即可 print(numbers) ## [1, 2, 3, 4, 5, 6] numbers[0] = 999 # 修改第一个元素的值为999 print(numbers) ## [999, 2, 3, 4, 5, 6] 添加元素 在List的最后添加元素可以用.append()。添加多个元素，可以用.extend()，注意extend使用一个list作为参数。插入元素到指定索引号.insert() letters = list(&quot;abcd&quot;) print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] letters.append(&#39;e&#39;)# 添加一个元素 print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] letters.extend([&#39;f&#39;,&#39;g&#39;]) #添加多个元素：把要添加的元素放进一个list里 print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] letters.insert(3,&quot;apple&quot;) #元素插入到指定索引的位置 print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;apple&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] 移除：移除某个元素，使用.remove()；按照索引移除del print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;apple&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] letters.remove(&#39;apple&#39;) # 如果&#39;apple&#39;不存在，会抛出错误：ValueError: list.remove(x): x not in list print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] del letters[0] print(letters) ## [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] 5.1.3 注意：List的拷贝 这部分可能有点抽象。 变量名是个标签 变量赋值，给内存中的一个数据“贴标签” 那用一个变量，给另一个变量赋值会如何？ 以一个数字来举例 a = 123 print(a) ## 123 b = a print(b) ## 123 a = 321 print(f&#39;a is {a}\\nb is {b}&#39;) ## a is 321 ## b is 123 中间发生了什么 a = 123 创建了一个整型对象，里面存放了123，把a这个名字绑定到这个对象上。 b = a 把a这个标签，所指代的对象，再贴一个标签b。这个时候,a和b都指向这个整型对象，里面存放了123。 a = 321 创建了一个新的整型对象，里面存放了321，把a这个名字，重新绑定到这个对象上。 现在 a -&gt; 321，b -&gt; 123 但List比较特殊 以letters来举例： a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] print(&#39;a is &#39;, a) ## a is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 变量a 指向 [\"a\", \"b\", \"c\", \"d\"] b = a 变量b 指向a相同的数据[\"a\", \"b\", \"c\", \"d\"] a[0] = &#39;apple&#39; print(&#39;b is &#39;, b) ## b is [&#39;apple&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 你修改了列表a的值，b的值也改变了！因为a和b一直指向同一个对象。 如果要避免这种情况，要明确地把a复制一次， a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] b = a.copy() print(f&#39;a is {a}\\nb is {b}&#39;) ## a is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] ## b is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] a[0] = &#39;apple&#39; print(f&#39;a is {a}\\nb is {b}&#39;) ## a is [&#39;apple&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] ## b is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 这样就不会互相干扰了。 总结： Number ,String,Tuple等，是“不可变类型”：修改这个变量，会创建一个对象，然后重绑定（转贴标签） List等，是“可变类型”：修改里面的值，其实是“原地修改”，导致所有指向这个数据的变量都发生改变。 要避免上述情况，请明确地复制原List一次。 5.1.4 List的切片 如何获取（或者修改）一个List中的某一段？ a = list(&#39;abcdef&#39;) print(a) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] 截取：从第2个元素开始到第4个元素：（证券答案应该是['b', 'c', 'd'] a[起点的索引 : 终点的索引-1] 如： a[1:4]：切片起止点：包含起点（1号，即b），不包含终点（不含4号，即e） print(a[1:4]) ## [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 可以不写起点或者终点，默认是到一边的尽头 print(a[:4]) # 4号元素之前（0，1，2，3）（不包含终点） ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] print(a[3:]) # 3号元素以及之后（3，4，5）（包含起点） ## [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;] 可以倒数切片： 如从倒数第二个元素开始到最后 print(a[-2:]) # 倒数第二个元素开始到最后（包含起点） ## [&#39;e&#39;, &#39;f&#39;] 从头切到倒数第二个元素（不含终点） print(a[:-2]) # 从头切到倒数第二个元素（不含终点） ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 切片赋值 ： 直接覆盖原理位置的值，可以不等长 a = list(&#39;abcdef&#39;) print(a[2:4]) ## [&#39;c&#39;, &#39;d&#39;] 注意：a[2:4]只有2个值，但我们替换成不等长的其他List，如替换3个值进去 a[2:4] = [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;] print(a) ## [&#39;a&#39;, &#39;b&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;e&#39;, &#39;f&#39;] 这使得['c', 'd'] -&gt; ['x', 'y', 'z'] 赋予空列表，可以达到删除的效果。 a[2:5] = [] # x,y,z是2，3，4号 print(a) ## [&#39;a&#39;, &#39;b&#39;, &#39;e&#39;, &#39;f&#39;] 还可以按步长切片 a[起点:终点:步长] 步长默认为1（每个元素都取值），如果设置为2，每2个元素取一个值 a = list(&#39;abcdefgh&#39;) print(f&#39;&#39;&#39;a is {a} a[1:6] is {a[1:6]} a[1:6:2] is {a[1:6:2]} &#39;&#39;&#39;) ## a is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] ## a[1:6] is [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] ## a[1:6:2] is [&#39;b&#39;, &#39;d&#39;, &#39;f&#39;] 5.1.5 其他常用操作 原地排序.sort(),默认的排序方式是“从小到大” 注意：这个方法会改变原List的顺序 a = [5,3,4,2,1] a.sort() print(a) ## [1, 2, 3, 4, 5] 也可以逆序：从大到小 a.sort(reverse=True) print(a) ## [5, 4, 3, 2, 1] 排序sorted()， 注意：sorted()回返回一个新的、排序后的List，不会改变原List的顺序。 a = [5,3,4,2,1] print(a) ## [5, 3, 4, 2, 1] print(sorted(a)) # 打印排序的结果 ## [1, 2, 3, 4, 5] print(a) # 原list的顺序并未改变 ## [5, 3, 4, 2, 1] 也可以逆序排序（从大到小） b = [3,4,5,1,2] print(sorted(b, reverse=True)) ## [5, 4, 3, 2, 1] 统计某个元素的数量 .count() a = [1,2,2,2,3,3,5,5,5,5,5] print(a.count(3)) # a中的3有多少个？ ## 2 查找某个元素第一次出现的索引 a = list(&#39;an apple&#39;) print(a) ## [&#39;a&#39;, &#39;n&#39;, &#39; &#39;, &#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] print(a.index(&#39;p&#39;)) ## 4 获取的List的长度 题外话：从长度可以知道，最后一个元素的索引号是长度-1 a = list(&quot;apple&quot;) print(a) ## [&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] print(len(a)) ## 5 获得最大最小值 a = [1,2,3,4,5] print(max(a)) # 如果包含不可比较大小类型，如str，会出错！ ## 5 print(min(a)) ## 1 5.2 元组Tuple 元组：同样是序列结构，可以视为“不可修改的列表”，其中的数据，一旦创建，就不可修改。 5.2.1 元组的创建 和List类似，但使用小括号创建。 注意，从打印的结果也可以看出，()表示元组，中括号[]表示列表。 a = (1,2,3,4,5) print(a) # 元组 ## (1, 2, 3, 4, 5) b = [1,2,3,4,5] print(b) ## [1, 2, 3, 4, 5] 如果元组只有1个元素，必须加一个逗号,，以避免python认为这是个运算。 a = (1,) # 正确的做法，识别成元组 print(a) ## (1,) b = (1) print(b) # 会被识别成一个数字 ## 1 也可以不用小括号，只使用逗号创建（为了维持代码的清晰和可识别，不建议这么做） a = 1,2,3,4,5 print(a) ## (1, 2, 3, 4, 5) 5.2.2 访问元组的元素 访问元组的方法和List完全一样，可以照搬。 但是“可读不可写”,不能做任何修改或删除。 a = (1,2,3,4,5) # 读取元素和获得切片等，和List完全一样 print(a[3]) ## 4 print(a[2:4]) ## (3, 4) a = (1,2,3,4,5) a[3] = 999 # 要对元组的值进行修改，会报错 TypeError: &#39;tuple&#39; object does not support item assignment 5.2.3 元组和列表的互转 List和Tuple用非常接近的结构，互相转换只要用前述的“简单类型转换”方法即可 a_list = list(&#39;apple&#39;) # str转为list a_tuple = tuple(a_list) # list转为tup;e print(a_tuple) # 注意，打印的结果是()小括号 ## (&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;) a_tuple = (1,2,3,4,5) # 创建一个tuple a_list = list(a_tuple) print(a_list) ## [1, 2, 3, 4, 5] 5.2.4 为什么要用tuple，不用list？ Tuple只有List的一半能力（只能读，不能改），只用List也可以完成Tuple的所有功能，那用Tuple有何意义？ List可能被意外修改，但Tuple不会 如前述，List是一个可变类型，可以有不止一个变量名指向同一个List数据。所以，使用List保存的数据，可能会在传递的过程中，在不经意间被你的某些代码所修改，比如忘记.copy()。 如果一个列表结构的数据，原则上不应该被改变，则可以采用Tuple。如果被代码意外修改，则会报错通知你。 Tuple一般会比List节约内存，但我们一般不必考虑这一点 5.3 字典Dict 和List或者Tuple类似，dict是很多数据的集合体 和List或者Tuple不同，dict中的数据不保证顺序， dict中的元素访问，是通过”键key”访问，一个key会对应一个value。 key的必须是不可变类型，如string，int，或者tuple。（tuple也可以做key） 和List一样，dict可以存放不同类型的数据 key是唯一的，如果对一个key赋予不同的值，那么新的value会替换旧的value. 这和新华字典类似： 通过这个字的拼音(即key)，找一个字的含义(value) 你一般不会通过这个字在字典中的第几个(index)来访问，虽然也不是不可以 5.3.1 创建dict 使用大括号，key:value的方式，key-value之间使用逗号分隔 {key1:value1, key2:value2, ... } 例如班级人数,一班50人，二班49人，三班30人。 这里使用class_x的字符串来做key，储存班级的人数。这个dict的作用是，可以通过班级的名称来获取班级的人数。 class_size = {&#39;class_1&#39;:50, &#39;class_2&#39;:49,&#39;class_3&#39;:39} print(class_size) ## {&#39;class_1&#39;: 50, &#39;class_2&#39;: 49, &#39;class_3&#39;: 39} 我们建立了一系列的映射，从字符串（本例中就是班级名称），到键值（本例中是班级人数的整型） \"class_1\" -&gt; 50 \"class_2\" -&gt; 49 \"class_3\" -&gt; 39 5.3.2 访问字典数据 字典数据的访问，和List或者Tuple一样，都是用中括号[]，但提供的数据的索引index，而是key（键名） # 获取一班的人数： # 一班的key是&quot;class_1&quot; print(class_size[&#39;class_1&#39;]) # 当然3班也一样 ## 50 print(class_size[&#39;class_3&#39;]) ## 39 修改其值也一样，直接赋值即可 class_size[&#39;class_3&#39;] = 40 print(class_size) ## {&#39;class_1&#39;: 50, &#39;class_2&#39;: 49, &#39;class_3&#39;: 40} 实际上，添加键值的方法就是直接赋值 例如，四班，key为class_4，人数为45，则： class_size[&#39;class_4&#39;] = 45 print(class_size) ## {&#39;class_1&#39;: 50, &#39;class_2&#39;: 49, &#39;class_3&#39;: 40, &#39;class_4&#39;: 45} 同样，删除键值的函数是del，和删除一个变量一样。 删除'class_4'。 del class_size[&#39;class_4&#39;] print(class_size) ## {&#39;class_1&#39;: 50, &#39;class_2&#39;: 49, &#39;class_3&#39;: 40} 5.3.3 获得所有键值 获得全部的key，使用.keys()方法。注意是复数，有个s。 print(class_size.keys()) ## dict_keys([&#39;class_1&#39;, &#39;class_2&#39;, &#39;class_3&#39;]) 注意，.keys()方法返回的不是一个List，所以我们一般还是转为List，便于进行其他操作。转换也是直接采用list()函数即可。 keys = list(class_size.keys()) print(keys) ## [&#39;class_1&#39;, &#39;class_2&#39;, &#39;class_3&#39;] 5.3.4 所有的value 获得全部的value，使用.values()方法。 print(class_size.values()) #同样是复数，有个s。 ## dict_values([50, 49, 40]) 同样，我们可以转换为List。 values = list(class_size.values()) print(values) ## [50, 49, 40] 5.3.5 其他操作 和List一样，dict也可以用len()函数获得数据的长度 print(len(class_size)) ## 3 5.3.6 别名与拷贝 和List一样，如果用一个dict为另一个dict赋值，那么2个变量和指向同一个数据，对其中一个数据的修改，会使得另一个变量中的数据也改变（毕竟只是同一个数据的2个名字） 要避免这一点，同样使用.copy()函数，拷贝一个dict。具体和List一样，这里不再重复。 5.3.7 不存在的key 如果我们直接读取一个不存在的key，会报错 class_size[&#39;class_9&#39;] key错误：即找不到’class_9’这key KeyError: &#39;class_9&#39; 但是，某些时候，我们想，如果key不存在，则返回一个默认值，而不要因为报错而中断程序。 这个时候可以使用.get()方法：如果key存在，则返回对应的value。如果不存在，则返回我们前面说过的None。 print(class_size.get(&#39;class_1&#39;)) # 获取一个存在的key ## 50 print(class_size.get(&#39;class_9&#39;)) # 获取一个不存在的key ## None 对于可能不存在的key，我们也可以使用自己指定的值。具体到本例，班级人数不可能是0，所以我们可以考虑用0来表示这个key（班级名称）不存在，或者你打错字了。 .get()这个方法的第二个参数，则是找不到key的时候的默认值。 print(class_size.get(&#39;class_9&#39;, 0)) ## 0 5.3.8 key是否存在 判断一个key是否存在， 也是用in。 print(&#39;class_1&#39; in class_size) # class_1是存在的 ## True print(&#39;class_9&#39; in class_size) # class_9是不存在的 ## False 5.3.9 （键-值元组） dict也可以视为一个类List的数据结构：其中每一个元素，是一个（键-值）对，即(key, value)的元组。 class_size = {&#39;class_1&#39;:50, &#39;class_2&#39;:49,&#39;class_3&#39;:39} print(class_size) ## {&#39;class_1&#39;: 50, &#39;class_2&#39;: 49, &#39;class_3&#39;: 39} 可以使用.items()这个方法，获取一个dict的所有(key, value)对。 print(class_size.items()) ## dict_items([(&#39;class_1&#39;, 50), (&#39;class_2&#39;, 49), (&#39;class_3&#39;, 39)]) 当然，我们也可以转为一个真正的List用list()函数 all_items = list(class_size.items()) print(all_items) ## [(&#39;class_1&#39;, 50), (&#39;class_2&#39;, 49), (&#39;class_3&#39;, 39)] 显然，这是3个(key, value)元组构成的List。 注意 1.最外层的中括号[]：这是一个List 2.每一个元素的小括号()：每一个元素是一个Tuple 看看第一个元素是什么？ print(all_items[0]) ## (&#39;class_1&#39;, 50) 易见，这就是一个（一班的名称, 一班的人数）组成的元组。 "],["条件与循环.html", "6 条件与循环 6.1 条件if 6.2 while循环 6.3 for循环 6.4 更多练习 6.5 列表推导式List Comprehension 6.6 循环Dict", " 6 条件与循环 6.1 条件if 6.1.1 多行if ifelse, ifelse price = 102 if price &lt;100: print (&#39;buy&#39;) elif price &lt; 110: print (&#39;hold&#39;) elif price &lt; 120: print (&#39;think about it&#39;) else: print (&#39;sell&#39;) ## hold 6.1.2 单行if price = 70 if price&lt;80: print(&#39;buy&#39;) ## buy 6.1.3 三元表达式 price = 85 &#39;buy&#39; if (price&lt;80) else &#39;don\\&#39;t buy&#39; ## &quot;don&#39;t buy&quot; 6.1.4 练习 小明身高1.75m，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 用if-elif判断并打印结果： 小提示： height = 1.75 weight = 80.5 # 计算BMI指数 # 用 if-elif 判断，并打印结果 判断闰年：从year, 判断是否为闰年? 注：能被4整除但不能被100整除的 或者 能被400整除 那么就是闰年 year = 2005 # 或者任何一年 6.1.5 嵌套if 例子：用if-else求a、b、c 3个数中最大的一个 思路： 比较a和b 1.1. 若a较大，则比较a和c 1.2. 若a较小，则比较b和c a = 4 b = 9 c = 2 if a&gt;b: if a&gt;c: max_value=a else: max_value=c else: if b&gt;c: max_value=b else: max_value=c print(f&quot;最大值是{max_value}&quot;) ## 最大值是9 6.1.6 练习 对一个变量number，判断是否能被2或者3整除 按具体的情况，请输出： “你输入的数字可以整除 2 和 3” “你输入的数字可以整除 2，但不能整除 3” “你输入的数字可以整除 3，但不能整除 2” “你输入的数字不能整除 2 和 3” 思路： 1. 先看看2 2. 再看看3 6.1.7 再谈布尔值 前面讲过，布尔型有2种，真True和假False。 实际上，这2个符号，是布尔型变量的值，和1,2,3,4是整型的值，'apple'是字符串的值类似。但布尔型的值只有2种。 例如，有一个变量，用于表示“现在是否下雨”。这个问题只有2个答案，是或者否，显然这就可以用布尔型来表示：True就表示下雨，False就表示没下雨。我们就定义一个布尔型变量is_raining。 注意：为了达到顾名思义的效果，布尔型的变量，可以考虑用is_，has_等等开头，显示这是个“是否”问题的答案。 # 表示现在正在刮风下雨 is_raining = True is_blowing = True 判断是否同时在刮风和下雨 print(is_raining and is_blowing) ## True 布尔运算，其结果，也是一个布尔类型的变量：因此可以赋值给另一个变量。 bad_weather bad_weather = is_raining and is_blowing # 布尔运算的结果，也是一个布尔型，并且可以赋值给另一个变量 print(bad_weather) ## True 换一种理解，你可以把and运算，看成一个函数。类似于： bool_and(x, y) 就可以视为一个函数调用，返回的结果，就是与操作 bad_weather = bool_and(is_raining, is_blowing) # 这是随便写的，无法执行 回到我们的if语句。if语句接受的判断条件，本质上一个布尔型变量 if is_raining and is_blowing: print(&#39;don\\&#39;t go outside!&#39;) ## don&#39;t go outside! 等价于： if bad_weather: print(&#39;don\\&#39;t go outside!&#39;) ## don&#39;t go outside! 所以，你在if后面跟一个布尔型变量bad_weather，或者一个条件is_raining and is_blowing，是等价的。但后者可以少进行一次赋值的操作，并且节约一个变量名。 回看前面的例子： a = 2 b = 3 if a &gt; b: print(&#39;a &gt; b&#39;) else: print(&#39;a &lt;= b&#39;) ## a &lt;= b 可以把a &gt; b看成是“一个布尔型的变量”，这个变量，保存了a &gt; b的结果，只是我们没有把这个结果赋值给一个变量名（没有绑定一个标签），而是直接放进了if语句中。 这等价于： a = 2 b = 3 is_a_bigger = a &gt; b if is_a_bigger: print(&#39;a &gt; b&#39;) else: print(&#39;a &lt;= b&#39;) ## a &lt;= b 小结，布尔运算，实际上会返回一个新的布尔值，可以和任何变量一样进行操作，比如绑定名字，放进if里等等 6.2 while循环 while循环比较直观，“只要条件成立，就重复执行某块代码块” 或者说，“重复执行某块代码块，直到条件不成立为止” while 判断条件(condition)： 执行语句(statements) 6.2.1 举例：打印 1到10 思想： 要把10以内的所有自然数都过一次，肯定要用循环 设计一个变量，用来做计数器，比如i 每次循环中，计数器累加1，直到10为止，停止循环 每次循环中，打印这个数 注：让变量自增的运算符号是+= 例如 i += 2即让i自增2，等价于 i = i + 2 i = 1 i += 999 print(i) ## 1000 设计一个从1到5的循环 i = 1 while i &lt;= 5: print(i) i +=1 else: print(&quot;循环结束&quot;) ## 1 ## 2 ## 3 ## 4 ## 5 ## 循环结束 6.2.2 练习 打印 1到10 中的偶数。 小提示：如何判断一个数是否是偶数？取余的操作符是% 利用循环，求1到100的累加，计算完成最后打印出来 小提示：你可以建立一个新的变量，用来存放累加的结果 6.3 for循环 6.3.1 如果没有for循环 例如，有一个班级同学姓名的列表，我们要打印每一个同学姓名的最后一个字母。 students = [&quot;Alex&quot;, &quot;Bob&quot;, &quot;Clare&quot;] print(students) ## [&#39;Alex&#39;, &#39;Bob&#39;, &#39;Clare&#39;] 没有循环的时候，我们怎么做？ 我们可能会尝试，把students这个列表，按索引号，逐一取出，然后再打印首字母 len(students) ## 3 知道students里有3个同学，我们就知道，索引号（index）是0，1，2。 现在我们用最笨的办法，逐一取出，逐一打印 s = students[0] # 取0号元素 print(s[-1]) # 打印最后一个字母 # 对其他2个元素，手动重复一次 s = students[1] print(s[-1]) s = students[2] print(s[-1]) x b e 显然， 如果元素很多，这就是个不可能完成的任务。 这个做法，重复的代码太多，必然可以得到精简 6.3.2 用while循环？ 我们前面学了while循环，我们尝试用while来做完成 同样，一个计数器i，记录了索引号，从0，到len(student) - 1 = 2 每次循环，用students[i]来取出对应的元素 打印最后一个元素 i += 1，循环 i = 0 while i &lt; len(students): # 注意，这里是 i &lt; 3 s = students[i] # 即i = 0, 1, 2 print(s[-1]) i += 1 ## x ## b ## e 6.3.3 用for循环 for s in students: print(s[-1]) ## x ## b ## e 6.3.4 比较 比较for循环，和手动操作 #%% do it yourself s = students[0] # 取0号元素 print(s[-1]) # 打印最后一个字母 # 对其他2个元素，手动重复一次 s = students[1] print(s[-1]) s = students[2] print(s[-1]) #%% for for s in students: print(s[-1]) 上述for循环完成的事： 自动把s指向students中的0号元素，对s执行你的代码（打印最后一个字） 自动把s指向students中的1号元素，对s执行你的代码（打印最后一个字） 自动把s指向students中的3号元素，对s执行你的代码（打印最后一个字） … 6.3.5 for循环 for循环一般用于遍历一个可迭代对象（简单理解，就是如 List、Tuple和Dict这样具有序列结构的数据） 其作用是“对其中的每一个元素都做点什么”。 如果你要对一个List中的每一个元素都做点什么，此时就应该用for循环。 例如，我们要打印a = [1,2,3,4,5]中的每一个元素 或者说，我们要对a = [1,2,3,4,5]中的每一个元素，执行打印这个动作。 a_list = [1,2,3,4,5] for i in a_list: print(i) ## 1 ## 2 ## 3 ## 4 ## 5 解释 目标：对a = [1,2,3,4,5]中的每一个元素，执行打印这个动作。 a_list是一个列表的名字 for i in a_list:：我们把中的每一个元素，按顺序，逐个过一遍。轮到哪个元素，我们就用i来指向它。 print(i)：由上一句，i可以看作每一个元素代称，我们打印它。注意，前面由“1个缩进”。 break a = [1,2,3,4,5] for i in a: if i &lt; 4: print (i) else: print(&#39;从这里断开！&#39;) break else: print(&#39;循环完成！&#39;) ## 1 ## 2 ## 3 ## 从这里断开！ 6.3.6 range的循环 range(起点, 终点, 步长)：快速生成一个序列：惰性的（lazy）可迭代序列 range(0,10)：生成一个0 ~ 9的自然数序列（包括起点，不包括终点） range(0,10,2)：生成一个0 ~ 8的偶数序列（包括起点，不包括终点） 可以转为List，如: print(range(0,10)) ## range(0, 10) print(list(range(0,10))) ## [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 但是，range不用转换为List，也可以使用！ 如：按索引取值，或者切片(range切片会得到另一个range)等等 print(range(10,15)[2]) ## 12 print(range(10,15)[2:4]) ## range(12, 14) 也可以替代List，用在for循环中，常用于快速生成一个数字序列 for i in range (1,10,2): print (&#39;奇数是: &#39;,i) ## 奇数是: 1 ## 奇数是: 3 ## 奇数是: 5 ## 奇数是: 7 ## 奇数是: 9 6.4 更多练习 求1~100之间能被7整除，但不能同时被5整除的所有整数。For和While版本 求列表（或者元组）平均值。For和While版本 score = [70, 90, 78, 85, 97, 94, 65, 80] 进阶思考题：二分查找法 对于一个排序的List，找到某一个元素的位置 思路 找到列表的中间位置的元素 比较这个元素，和目标的大小。如果一样大，得到位置。 根据大小，把范围缩小到List前半段，或者后半段 在新的区间，回到1. 重复这个过程 a = [ 5,8,15,20,30,45,78,100,120,200 ] target = 30 6.5 列表推导式List Comprehension 更详细的内容见后。 遍历List，并进行某个操作 do_something(i) for i in a_list s = [&#39;abc&#39;,&#39;abcd&#39;,&#39;bcde&#39;,&#39;bcdee&#39;,&#39;cdefg&#39;] [x.upper() for x in s] ## [&#39;ABC&#39;, &#39;ABCD&#39;, &#39;BCDE&#39;, &#39;BCDEE&#39;, &#39;CDEFG&#39;] 遍历List，找出符合条件的值，并对其进行某个操作 do_something(i) for i in a_list if condition(i) old_list = [&#39;abc&#39;,&#39;abcd&#39;,&#39;bcde&#39;,&#39;bcdee&#39;,&#39;cdefg&#39;] matching = [ x.upper() for x in old_list if &#39;bcd&#39; in x ] print( matching ) ## [&#39;ABCD&#39;, &#39;BCDE&#39;, &#39;BCDEE&#39;] 6.6 循环Dict d = {&quot;x&quot;: 1, &quot;y&quot;: 2} for key in d: print(key, d[key]) ## x 1 ## y 2 "],["函数.html", "7 函数 7.1 定义一个函数 7.2 参数 7.3 参数作为可变类型和不可变类型 7.4 递归简介（进阶） 7.5 变量作用域", " 7 函数 一个函数，就是一个包装好的代码：你给它一些输入（参数），函数给你一个结果（返回值）： 比如，如果把电饭锅看成是一个函数，那么参数就是“米，水，电，时间”，你把“米，水，电，时间”给电饭锅，电饭锅返回给你一锅“米饭”。 写成代码，大概是： 米饭 = 电饭锅(米，水，电，时间) 这完全可以看成一个转换，或者映射 \\[ (米，水，电，时间) \\longmapsto 米饭 \\] 我们面前已经用过的，比如求List的长度： a = [1,2,3,4,5] a_size = len(a) print(a_size) ## 5 看a_size = len(a)这个代码 len() ：函数名 len(a) ：其中a是参数，即“你提供给这个函数的东西” a_size = len(a)：会返回a的长度（元素的数量），你把这个结果放在变量a_size之中 7.1 定义一个函数 在python中 定义一个函数的关键字是def， def后，是函数名，小括号内是参数（这个函数要接收的东西），最后是冒号 函数体，要有“1个缩进” 返回关键词是return。如果函数执行完都没有遇到return，则返回none 7.1.1 例：加法函数 举一个最简单的例子，我们要写一个加法函数，其作用就是把2个变量相加。或者说，你给这个函数“传递2个参数”，这个函数会返回他们的和。 #%% 定义一个加法函数 def add(x, y): z = x + y return z 逐行解释一下 第一行： def add(x, y): 定义一个函数，由def开头 接着是你给这个函数起的名字add 名字后面是小括号，里面包含了这个函数的“参数”。这里是2个参数，命名为x和y。显然，这就是你调用这个函数的时候，要给函数的东西。 最后是冒号，不要忘记 注意：关于参数，2个参数的名字你可以自己定义，不一定是x和y。这2个参数的名字，如同一切变量名一样，最终会”指向”2个值，所以你在函数的内部，就可以用这2个名字，来引用这2个值 第二行：z = x + y 注意，前面有“1个”缩进，指示这个语句比函数本身低一级 z = x + y，一目了然。需要说明的是，函数体内的2个参数，调用的时候已经有指向的目的地了。所以不会出现类似x不存在之类的错误。 第三行：return z 前面还是“1个”缩进，这是和z = x + y同一个层级的代码。 返回使用return语句。这里把和z，返回给上一层。 定义好之后，我们可以像使用任何函数一样调用它 我们来一个很熟悉的代码。 a = 1 b = 2 c = add(a, b) print(c) ## 3 7.1.2 例：求两个数的最大值 思路： 如果x &gt; y，则返回x。 否则返回y。（x &lt;= y，此时返回y也是最大值） #%% 定义一个函数，接收两个参数，返回其最大值 def my_max(a, b): if a &gt;= b: return a # 返回a else: return b # 返回b print(my_max(3,5)) ## 5 7.1.3 例：计算圆的面积 另一个例子，已知：圆的半径是\\(r\\)，我们要计算圆的面积，公式就是\\(y = \\pi r^2\\)。 我们准备写一个函数来做这件事： 这个函数会根据我们提供的半径\\(r\\)，返回一个圆的面积给我们。 显然，这个函数必然是接受r作为参数 我们做的，是算出面积，然后返回一下 def calc_area(r): area = 3.14159 * (r ** 2) return area ] x = 5 area = calc_area(x) print(f&quot;半径为{x}的圆，其面积为{area:0.2f}&quot;) ## 半径为5的圆，其面积为78.54 7.1.4 不返回值 若函数不需要返回任何值，不写return语句，或者return语句后不返回任何值 #%% 这2种都是可以的 def hello(): print(&quot;hello&quot;) # 不写return def hello2(): print(&quot;hello&quot;) return # 写return但不包括返回值 hello() ## hello hello2() ## hello 7.1.5 什么也不做的函数 有时候需要先占用函数名，但是函数的内容想以后再写，此时可以写一个空函数。函数体内只需要使用pass语句。 特别地，没有return语句（例如现在这种情况），或者return语句不返回值的时候，函数会返回一个none。 def do_noting(): pass print(do_noting()) ## None 7.2 参数 7.2.1 使用参数名 把参数传递给函数，可以按参数的顺序，也可以使用参数的名称 7.2.2 例：使用参数名称传递参数 def print_info(name, age): print(&quot;姓名: &quot;, name) print(&quot;年龄: &quot;, age) print_info(&#39;alex&#39;,20) # 按参数顺序：姓名，年龄 ## 姓名: alex ## 年龄: 20 print (&quot;------------------------&quot;) ## ------------------------ print_info(age = 21, name = &quot;bob&quot;) # 按参数名，此时不用考虑参数的顺序 ## 姓名: bob ## 年龄: 21 7.2.3 默认参数 定义函数的时候，可以给某些参数定义一个默认值。 默认参数必须定义在最后。 7.2.4 例：乘方函数（n次方） def power(x, n=2): # n有默认值 return x ** n print(power(5)) # 调用函数不传递n的值，使用默认值，结果为25 ## 25 print(power(3, 3)) # 调用函数传递n的值，使用传递值，结果为27 ## 27 7.2.5 不定长参数（进阶） 函数可以接受任意多个参数，例如求最大值的函数max() print(max(4,1,5,2)) ## 5 你要写一个这样的函数，那么可创建一个新的参数，前面带一个*号。那么不在参数列表里的参数，会组成一个tuple，并且绑定带这个带*号的变量名。 # 第一个参数是class_id，从第二个参数起，不定数量个参数，都会组成一个tuple，并命名为`students`(没有*) def print_students(class_id, *students): &#39;打印班级号，和同学的姓名&#39; print(&quot;班级:&quot;,class_id) print(&quot;学生包括:&quot;, students) for s in students: # 也可以逐一打印 print (s) print_students(5 ,&quot;alex&quot;,&quot;bob&quot;,&quot;clare&quot;) ## 班级: 5 ## 学生包括: (&#39;alex&#39;, &#39;bob&#39;, &#39;clare&#39;) ## alex ## bob ## clare 实际上，如果你有可变参数的函数，如print_students，但是你拿到的数据是一个List，怎么办？ 土办法，把列表元素一个个拿出来，传给函数 students_list = [&quot;alex&quot;,&quot;bob&quot;,&quot;clare&quot;] # 这已经是一个list print_students(5, students_list[0],students_list[1],students_list[2]) ## 班级: 5 ## 学生包括: (&#39;alex&#39;, &#39;bob&#39;, &#39;clare&#39;) ## alex ## bob ## clare 当然，也简单的办法，变量在传递给函数时，前面加个*，python会自动帮你拆开 students_list = [&quot;alex&quot;,&quot;bob&quot;,&quot;clare&quot;] # 这已经是一个list print_students(5, *students_list) # 自动把students_list这个List，拆成多个元素 ## 班级: 5 ## 学生包括: (&#39;alex&#39;, &#39;bob&#39;, &#39;clare&#39;) ## alex ## bob ## clare 练习：利用不定数量参数，写一个函数my_sum()，可以求任意个变量的和。 def my_sum(*numbers): pass # 内容由你填写 print(my_sum(1,2,3,4)) # 10 ## None print(my_sum(3,4,5)) # 12 ## None 7.2.6 可变参数以dict形式传递 参数前加1个*，可变参数就会组成一个元组tuple，进入函数。2个**，就会以字典dict进入函数 （略） 7.3 参数作为可变类型和不可变类型 前面提到，多个变量名指向同一个可变对象（例如List，Dict），针对其中一个变量的修改，会引起所有指向同一个数据的变量都发生改变。 把List等，作为参数传递个一个函数，也有类似的后果。 下例中， 把a_list作为参数x，转递给函数do_change(x)，那么在函数内部，变量x和外部a_list指向的是同一个数据，或者说，x成了a_list的别名。 把x作为函数的返回值，返回到外层，并赋予b_list，那么b_list, x, a_list，三个名字，实际上都指向了内存中的同一块数据。 当然，x只在函数体内可见。 a_list = list(&#39;apple&#39;) # a_list -&gt; [&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] def do_change(x): x[0] = &#39;B&#39; return x b_list = do_change(a_list) # 把a_list作为参数，则函数的参数 x -&gt; a_list print(b_list) ## [&#39;B&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] print(a_list) ## [&#39;B&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] 同意，如果你的设计意图并非“原地修改”，原变量必须保持不变，则可以把x拷贝一份。 a_list = list(&#39;apple&#39;) # a_list -&gt; [&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] def do_change(x): y = x.copy() # 把x拷贝一份，对y进行修改，那么x就保持不变了 y[0] = &#39;B&#39; return y b_list = do_change(a_list) # 把a_list作为参数，则函数的参数 x -&gt; a_list print(b_list) ## [&#39;B&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] print(a_list) ## [&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] 若传递的参数是不可变类型，如int，str等，则对参数的修改会自动引发拷贝，没有上述问题。前面已经说过了。 7.4 递归简介（进阶） 递归：函数自己调用自己调用自己调用自己调用自己 … 例子，阶乘\\(n! = n \\times (n-1) \\times (n-2) ... 2 \\times 1\\) 如 \\(5! = 5 \\times 4 \\times 3 \\times 2 \\times 1\\) 普通写法 def f(n): result = n for i in range(1, n): # 注意，range(1,n)，只到 n-1 result *= i return result result = f(5) print(result) ## 120 递归的写法 \\(f(n) = n * f(n-1)\\) \\(f(n - 1) = (n - 1) * f(n - 2)\\) \\(f(n) = n * (n - 1) * f(n - 2)\\) def f(n): if n == 1: return 1 # 递归终止条件 else: return n * f(n-1) # 递归：自己调用了自己 result = f(5) print(result) ## 120 7.5 变量作用域 你在函数里调用了一个变量名，python会“从里到外”找这个变量，顺序是LEGB LEGB含义解释：（暂时不用管） L-Local(function)即局部名称；函数内的名字空间 E-Enclosing function locals即函数中嵌套函数的外部；外部嵌套函数的名字空间(例如closure) G-Global(module)即全局名称；函数定义所在模块（文件）的名字空间 B-Builtin(Python)即内置名称；Python内置模块的名字空间 7.5.1 局部作用域 a = 10 # 全局变量a def func(): a = 20 # 局部变量a。在定义了局部变量a之后。后面使用a这个变量名，将会首先找到这个变量（即从里到外找） print(a) # 应该是20 func() ## 20 a = 10 # 全局变量a def func(): print(a) # 在函数内部，没有变量a，那么就往外一层找，因此会找到全局变量`a`，应该等于10 func() ## 10 注:：函数內部和外部变量重名的情况，要额外小心。因此第二个例子可能是你“忘记了在函数内部定义a”，而不是你想要“引用全局变量a”，但是因为有一个全局的变量a，所以忘记定义a这个问题可能会被隐藏。 7.5.2 全局作用域 特别地，函数内部的赋值语句，其中的变量会被python看作一个local变量，如果内部未定义，就可能出错。 a = 100 # 全局变量a def func(): a = a + 1 # a + 1这个a系统认为是局部变量，但这个函数没有局部的a print(a) # 全局变量a func() UnboundLocalError: local variable &#39;a&#39; referenced before assignment 所以，如果你明确地要用一个函数外的变量，那么可以使用global关键字 a = 100 # 全局变量a def func(): global a # 说明：a这个变量名，指向的是全局变量a a = a + 1 print(a) # 全局变量a func() ## 101 "],["函数式编程简述.html", "8 函数式编程简述 8.1 map和filter 8.2 高阶函数", " 8 函数式编程简述 8.1 map和filter 8.1.1 map 有一个List，a = [1,2,3,4,5]，你现在要把其中的每一个元素都乘以2，并保存在一个新的List中。用现有的知识，可以这样 建立一个空的List用来保存结果result = [] 循环a中的所有元素，并且乘以2，添加到result的末端 a = [1,2,3,4,5] print(a) ## [1, 2, 3, 4, 5] result = [] for i in a: result.append(i*2) print(result) ## [2, 4, 6, 8, 10] map函数，可以把一个函数，应用到List中的所有元素上。 def do_double(x): &#39;翻倍函数&#39; return x * 2 print(do_double(3)) ## 6 把do_dobule函数，应用到列表a中的每一个元素里。 result = map(do_double, a) # 把do_dobule函数，应用到列表a中的每一个元素里。 print(list(result)) ## [2, 4, 6, 8, 10] 也可用列表推导 result = [i * 2 for i in a] print(result) ## [2, 4, 6, 8, 10] result = [do_double(i) for i in a] print(result) ## [2, 4, 6, 8, 10] 把a里的元素，全部转换为str result = map(str, a) # 把str函数，应用到列表a中的每一个元素里。 print(list(result)) ## [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;] 8.1.2 filter 有一个List，a = [1,2,3,4,5]，你现在要选出符合特定条件的元素，例如选出其中的奇数，组成一个新的List。用循环做： a = [1,2,3,4,5] result = [] for i in a: if i % 2 == 1: result.append(i) print(result) ## [1, 3, 5] 和map一样，定义一个is_odd函数，作为filter的过滤条件，应该返回布尔值(True/False)，作为是否符合条件的结果。 def is_odd(x): return x % 2 == 1 print(is_odd(3)) ## True print(is_odd(6)) ## False filter(判断函数, List) result = filter(is_odd, a) print(list(result)) ## [1, 3, 5] 当然，也可以用列表推导 [i for i in a if is_odd(i)] ## [1, 3, 5] 8.1.3 混合map和filter 选出a中的奇数，并乘以2 map 和 filter的做法 result = list(map(do_double, filter(is_odd, a))) print(result) ## [2, 6, 10] 列表推导的做法 result = [do_double(i) for i in a if is_odd(i)] print(result) ## [2, 6, 10] 这其实可以理解为一个“数据流的概念”： &#39;&#39;&#39; a -&gt; filter by is_odd() -&gt; map by do_double() -&gt; reuslt &#39;&#39;&#39; ## &#39;\\na \\n-&gt; filter by is_odd()\\n-&gt; map by do_double()\\n-&gt; reuslt\\n&#39; 列表a首先经过filter函数的加工，然后再经过map函数的加工，最后得到reuslt。 比喻：一堆水果(数据）-&gt; 剔除坏的（处理1）-&gt; 清洗（处理2）-&gt; 削皮（处理3）-&gt; 榨汁（处理4） -&gt; 果汁（处理后的数据） 注： 多数情况下，列表推导和map/filter函数几乎可以相互替代 列表更加符合Python的“风格” 但超级巨大List时，用map/filter性能更好：map/filter是一个lazy（惰性）函数，只有在你引用其中的值时，才会把函数真正应用上去。 map/filter的结果，最后要转为list 所以 清晰性：列表推导 &gt; map/filter函数 &gt; 循环 性能：map/filter函数 &gt; 列表推导 &gt; 循环 从逻辑上来讲，应该是先有map/filer：要把一个函数应用到List中的所有元素/过滤元素，这是个基础性的需求，大多数编程语言都有做这件事的办法。我们一般把这种操作统称为map/filter。Python的列表推导，可以看成是一个Python优化版的map/filter。 8.1.4 匿名函数 lambda 在我们使用map、filter，或者列表推导的时候，如果要对列表做的操作非常简单、一目了然，并且可以写进一行（比如乘以二，或者取最后一个字母等等），那么我们可以不用专门写一个函数，而直接放一个匿名函数进去。 使用lambda关键字，一个表达式，直接返回这个表达式的结果，不用写return。 写法一般是： lambda &lt;参数列表&gt;: &lt;对参数的操作&gt; 例如一个匿名版本的add(a,b)函数： lambda a,b : a + b 或者一个匿名的翻倍函数： lambda x: x * 2 以把一个列表所以元素翻倍为例： 用普通函数：事先定义了一个do_double函数，这个函数返回参数x2 result = map(do_double, a) print(list(result)) ## [2, 4, 6, 8, 10] 用匿名函数：乘以2这类简单操作，用匿名函数即可，可以省下预先定义do_double函数。 result = map(lambda x : x * 2,a) print(list(result)) ## [2, 4, 6, 8, 10] 注： 对于初学者，如果不是一个超级简单的操作，建议还是应该用一个可以“顾名思义”的函数。 8.1.5 map和filter的结果：惰性 如果我们直接打印map和filter的结果，我们会发现，它们的返回值不是一个List，而是一个map object或者filter object。 这是因为map和filter，不会在你调用map()/filter()函数的时候马上进行计算，而是在你读取其中的值的时候，才进行具体计算。我们称之为“惰性求值”。 例如，用前面的List翻倍的例子。 a = [1,2,3,4,5] result = map(lambda x : x * 2,a) # 当你调用map的时候，并未真正地进行计算 print(result) ## &lt;map object at 0x7fbe20fa2be0&gt; 所以，当你把map()/filter()函数的结果打印出来看的时候，python会告诉你，这是个map/filter object，即map/filter函数的结果。但是，里面具体的数据还没计算出来，所以没法直接使用 要用，很简单，用list()函数转换为一个列表即可。 print(list(result)) ## [2, 4, 6, 8, 10] 当然，如果你使用列表推导，那么结果直接就是一个List。 result = [i * 2 for i in [1,2,3,4,5]] print(result) ## [2, 4, 6, 8, 10] def is_even(x): return x &amp; 1 != 0 filter(is_even, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) ## &lt;filter object at 0x7fbe20fa46d0&gt; 8.2 高阶函数 在python中，函数是一等公民（头等函数，first-class function）。 一个函数，可以和任何变量或者对象一样，绑定一个名字（函数名），也可以换一个名字（重绑定），也可以作为参数传递给另一个函数（函数作为参数传另一个函数），也可以作为一个函数的返回值（函数返回另一个函数）。 8.2.1 函数是一等公民 def add(x,y): return x + y print(add(1,2)) ## 3 函数和变量一样，其名字也可以重新绑定. dda = add之后，dda和add指向同一个函数（加法函数），dda()也可以正常调用。 dda = add print(dda(1,2)) ## 3 8.2.2 函数作为参数 例如map，可以把一个指定的函数，应用到List的每一个元素上。 map()函数的第一参数，就是你要应用到List元素上的函数， 比如前例中乘以2do_double，这里是把函数do_double作为参数传递给了map。第二个参数，就是你要处理的List。 result = map(do_double, [1,2,3,4,5]) print(list(result)) ## [2, 4, 6, 8, 10] 8.2.3 “函数生成器”（进阶） 用参数来生成不同的函数。 例如，我们写一个函数，用于求一个数x的n次方。显然我们可以写一个这样的函数。 def power(x,n): return x ** n 例如，3的平方： print(power(3,2)) ## 9 例如，2的3次方： print(power(2,3)) ## 8 平方、三次方等等，非常的常用，我们想写个专门的函数，可以少输入一个参数 def square(x): return power(x,2) print(square(3)) ## 9 同样，三次方也是 def cube(x): return power(x,3) print(cube(2)) ## 8 我们看到，这2个函数，函数体几乎完全一样，只有1个地方不同：2和3。 如果某些场合，4次方也很常用，我们可以原样建立一个4次方函数。 但是，这么多的函数，只有1个地方不同，必定是可以再往上抽象一层。 这个函数，可以根据你给的参数n，生成另一个函数：n次方函数生成器 def make_power_funcion(n): def func(x): # return power(x, n) # 也是一样的 return x ** n return func make_power_funcion是一个函数，这个函数会返回另一个函数func &#39;&#39;&#39; 约等于以下代码 def func(x): n = 2 return x ** n square = func &#39;&#39;&#39; ## &#39;\\n约等于以下代码\\n\\ndef func(x):\\n n = 2\\n return x ** n\\n\\nsquare = func\\n&#39; square = make_power_funcion(2) cube = make_power_funcion(3) print(square(3)) ## 9 print(cube(2)) ## 8 8.2.4 reduce （进阶） reduce和map一样，不单是一个具体的函数，同时也是“一种常用的操作”，所以放在大部分编程语言中，都有相同的含义。因此一般会与map并列，常称之为map/reduce。 和map一样，reduce同样可以把一个函数应用到一个列表上，区别在于，你使用reduce的时候，你要运用的函数，例如func(x,y)，有2个参数。 reduce会这么做： 取出你要处理的列表的头2个元素（a[0]和a[1]），传进func(a[0], a[1])中，并得到一个返回值，如z1 取出列表的第3个元素a[2]，和前一个结果，一起传入func(z1,a[2])，得到一个返回值，如z2 取出列表的第4个元素a[3]，和前一个结果，一起传入func(z2,a[3])，得到一个返回值，如z3 … 例如，我们对一个列表a = [1,3,5,7,9]，reduce一下应用我们前面写的add()函数。 显然，这个操作大概是这个过程。 reduce函数在functools模块中，模块我们后面会讲。要引入reduce函数，使用这行代码： from functools import reduce from functools import reduce a = [1,3,5,7,9] reduce(add,a) ## 25 8.2.5 闭包Closure（进阶） 一个闭包closure，可以认为是一个函数，但除了函数体本身，包含了定义闭包时的数据。 例如 def make_power_funcion(n): def func(x): # return power(x, n) # 也是一样的 return x ** n return func 这个代码里，调用power()函数，会返回另一个函数fun()。 这个函数里面调用了变量n，但n不在fun()的函数体内，而在上一层。fun()函数，会把生产自己的坏境中的变量（本例中即n），也包括在里面：闭包是一个附带数据的函数。 这段代码发生了什么？ square = make_power_funcion(2) square函数，相当于一个附带了n=2的func()函数 power(n = 2)，其中n = 2 在make_power_funcion()函数的内部，func(x)是可以看见这个n=2的 return func的时候，会把n=2，一并返回到外层 square = power(2),此时我们把square这个名字，绑定给func这个函数（闭包），而后者同时还附带了n=2 前面讲变量作用域，python找一个名称，是从内到外 L局部作用域：即函数体内。例如本例中func函数的x Enclosing function locals：函数中嵌套函数的外部：例如本例中func函数的n G全局：代码的最外层 B内置名称：python的一些内置的名称，如max函数 现在可知，python查找变量名，先找局部作用域（函数内部），再找闭包的附带数据，再找全局变量，再找python的内置名称。 "],["模块module-施工中.html", "9 模块module （施工中） 9.1 引入模块 9.2 Python常用模块 9.3 自定义模块 9.4 包package", " 9 模块module （施工中） 一个.py文件，就是一个模块module，里面的函数、变量等等，可以被其他代码所调用。 9.1 引入模块 先引入python自带的模块。例如用于数学运算的math，其中有大量函数，例如开平方根sqrt就在其中。 注：math模块下的全部内容，见python文档：https://docs.python.org/zh-cn/3.8/library/math.html 9.1.1 import import &lt;模块名&gt; import &lt;模块名&gt; as &lt;简称&gt; 注意：只要import一次，即可一直使用。一般我们可以放在代码的最前面。 我们可以用&lt;模块名&gt;.&lt;函数名/变量名&gt;来调用里面的函数或者变量，例如我们要调用math模块下的平方根sqrt()。 此时，模块内部的所有东西（函数、变量等），都必须通过&lt;模块名&gt;.来调用。 import math print(math.sqrt(4)) ## 2.0 或者math中的圆周率。 print(math.pi) ## 3.141592653589793 也可以采用简称或者缩写，例如想把math缩写成m import math as m print(m.sqrt(4)) ## 2.0 9.1.2 引入到当前名字空间 这种方法让模块内部的函数或者变量名，直接出现在当前名字空间中（调用的使用不用再挂着模块的名字）。如果这个模块下的某些东西特别常用，这样可以少打一些字 引入方法。 from &lt;模块名&gt; import &lt;函数/变量名&gt; as 简称 还是引入math中的开平方函数sqrt，可能你的代码中使用特别多，所以懒得打math.sqrt()，只想打sqrt() 同样，import一次，后续即可一直使用。 from math import sqrt print(sqrt(9)) ## 3.0 print(sqrt(4)) ## 2.0 还可以一次性引入模块下的所有名字 from &lt;模块名&gt; import * 这样你引用模块下的所有对象，都不必通过模块名来调用。 注意：`这种方式不推荐。引入大量的你可能用不到，甚至不知道存在的东西，不是一个好习惯。 9.2 Python常用模块 9.2.1 os模块 详细内容请参与官方文档： https://docs.python.org/zh-cn/3/library/os.html 首先要import一下 import os 列出目录 os.listdir(&quot;.&quot;) ## [&#39;.git&#39;, &#39;.gitignore&#39;, &#39;.RData&#39;, &#39;.Rhistory&#39;, &#39;.Rproj.user&#39;, &#39;.write-test-ba37ef77-b4d0-4ad6-b54f-31c730bf7e57&#39;, &#39;.write-test-ccf19519-dfa1-42cc-995f-ab1154aaa100&#39;, &#39;01-run-python.Rmd&#39;, &#39;02-use-spyder.Rmd&#39;, &#39;03-var-and-datatype.Rmd&#39;, &#39;04-data-structures.Rmd&#39;, &#39;05-Control-and-Loops.Rmd&#39;, &#39;06-function.Rmd&#39;, &#39;07-module.Rmd&#39;, &#39;08-useage.rmd&#39;, &#39;09-OO.rmd&#39;, &#39;10-NumPy.rmd&#39;, &#39;book.bib&#39;, &#39;hypothesis.html&#39;, &#39;images&#39;, &#39;index.Rmd&#39;, &#39;my_calc.py&#39;, &#39;open_review_block.html&#39;, &#39;packages.bib&#39;, &#39;preamble.tex&#39;, &#39;Python for Social Scientists.Rproj&#39;, &#39;README.md&#39;, &#39;style.css&#39;, &#39;upload&#39;, &#39;_book&#39;, &#39;_main.Rmd&#39;, &#39;_output.yml&#39;, &#39;__pycache__&#39;] 9.2.2 time模块 9.2.3 str模块 9.2.4 math模块 9.3 自定义模块 要完成一个特定的项目，你可能要写不计其数代码，没有理由把这么多代码都放在一个.py文件下。 一般可以把相关的代码，放在一个.py文件中，然后在其他文件里用模块的方式调用。 例如，我们前面写过一个add函数，可以把2个数相加。 def add(x,y): return x + y print(add(1,2)) ## 3 也写过一个翻倍函数 def do_double(x): return x * 2 print(do_double(2)) ## 4 这2个函数，显然都可以归类为计算函数，我们把中2个函数放到一个专门的文件中，例如my_calc.py 文件my_calc.py的内容。 def add(x,y): return x + y def do_double(x): return x * 2 在我们后续的任务中，如果要调用这2个函数，就可以用import import my_calc print(my_calc.add(1,2)) ## 3 当然，如简称、直接导入名称等等，和前述一样。 以后，你就可以按照你自己逻辑，如同类的函数、数据，完全特定任务需要的组件等等，来组织自己的模块。 按逻辑把你的代码分类组织，是一个好习惯。 9.4 包package 多个模块，可以组成一个包。（略） "],["综合应用.html", "10 综合应用 10.1 从数据开始 10.2 添加功能 10.3 综合练习", " 10 综合应用 10.1 从数据开始 例如，我们要一个程序来处理班级同学的信息。每个同学起码有这几个信息： 学号 姓名 专业 班级号 用现在所学的信息，我们可以用字典dict来表示任何一个同学。 student_1 = {&#39;student_id&#39;:2021001, &#39;name&#39;:&#39;Alex&#39;, &#39;major&#39;: &#39;finance&#39;, &#39;class_id&#39;:1} student_2 = {&#39;student_id&#39;:2021002, &#39;name&#39;:&#39;Bob&#39;, &#39;major&#39;: &#39;finance&#39;, &#39;class_id&#39;:1} student_3 = {&#39;student_id&#39;:2021003, &#39;name&#39;:&#39;Clare&#39;, &#39;major&#39;: &#39;accounting&#39;, &#39;class_id&#39;:2} print(student_1) ## {&#39;student_id&#39;: 2021001, &#39;name&#39;: &#39;Alex&#39;, &#39;major&#39;: &#39;finance&#39;, &#39;class_id&#39;: 1} print(student_2) ## {&#39;student_id&#39;: 2021002, &#39;name&#39;: &#39;Bob&#39;, &#39;major&#39;: &#39;finance&#39;, &#39;class_id&#39;: 1} print(student_3) ## {&#39;student_id&#39;: 2021003, &#39;name&#39;: &#39;Clare&#39;, &#39;major&#39;: &#39;accounting&#39;, &#39;class_id&#39;: 2} 显然，同类数据，我们可以组成一个List，或者另一个Dict。 # List版本 students_info = [ student_1, student_2, student_3 ] print(students_info) ## [{&#39;student_id&#39;: 2021001, &#39;name&#39;: &#39;Alex&#39;, &#39;major&#39;: &#39;finance&#39;, &#39;class_id&#39;: 1}, {&#39;student_id&#39;: 2021002, &#39;name&#39;: &#39;Bob&#39;, &#39;major&#39;: &#39;finance&#39;, &#39;class_id&#39;: 1}, {&#39;student_id&#39;: 2021003, &#39;name&#39;: &#39;Clare&#39;, &#39;major&#39;: &#39;accounting&#39;, &#39;class_id&#39;: 2}] 10.2 添加功能 10.2.1 查找 显然按条件查找是必须有的功能 例如：查找Alex的信息 既然students_info是一个列表，那我们就用列表推导。 result = [s for s in students_info if s[&#39;name&#39;] == &quot;Alex&quot;] print(result) ## [{&#39;student_id&#39;: 2021001, &#39;name&#39;: &#39;Alex&#39;, &#39;major&#39;: &#39;finance&#39;, &#39;class_id&#39;: 1}] 注意：列表推导的结果，也是一个列表，即使其中只有1个元素。看打印的最2边是中括号。 那么有多少个同学叫Alex? len(result) ## 1 那我们可以获得Alex的信息，例如学号和专业 print(result[0][&#39;student_id&#39;]) ## 2021001 print(result[0][&#39;major&#39;]) ## finance 按人名查找，是一个特别常用的功能，那我们把这个功能写成一个函数： def find_students_by_name(data, name): &#39;&#39;&#39; 按名字查找同学 &#39;&#39;&#39; result = [s for s in data if s[&#39;name&#39;] == name] return result result = find_students_by_name(students_info,&quot;Alex&quot;) print(result) ## [{&#39;student_id&#39;: 2021001, &#39;name&#39;: &#39;Alex&#39;, &#39;major&#39;: &#39;finance&#39;, &#39;class_id&#39;: 1}] 10.2.2 练习：按学号查找 按学号查找，但学号是唯一的，因此逻辑上只能有一个数据。 因此，获得的数据之后，不返回列表，只返回代表学生的dict。 如果学号有重复，打印一个警告信息：“学号有重复！请检查！” def find_student_by_id(data, student_id): &#39;&#39;&#39; 按学号查找同学 &#39;&#39;&#39; pass # 这部分由你完成 result = find_student_by_id(students_info, 2021002) print(result) ## None 10.2.3 简单统计 统计一下，金融专业有多少人？ 先筛选（利用上面的知识） 再算数 finance_students = [s for s in students_info if s[&#39;major&#39;] == &#39;finance&#39;] len(finance_students) ## 2 当然，也可以写个2函数：同样，先查找，在统计 def find_students_by_major(data, major): &#39;&#39;&#39; 按专业查找同学 &#39;&#39;&#39; result = [s for s in data if s[&#39;major&#39;] == major] return result def count_by_major(data, majoy): &#39;&#39;&#39; 计算专业的同学人数 &#39;&#39;&#39; class_size = len(find_students_by_major(data,majoy)) return class_size print(&#39;金融专业人数:&#39;, count_by_major(students_info, &#39;finance&#39;)) ## 金融专业人数: 2 print(&#39;会计专业人数:&#39;, count_by_major(students_info, &#39;accounting&#39;)) ## 会计专业人数: 1 小结： 考虑怎么组织数据： “一位同学”的信息可以用字典Dict：可以用student_id等标签，来获取该同学信息。 “所有同学”的信息可以用列表List：所有同学，可以看作一个有序的队列，自然可以采用List。大量的列表操作，便于我们进行查找、筛选、统计等等。 常用的操作，可以写成函数。既便于使用，又可以通过函数名得知操作的意图，一目了然。 函数名，应该顾名思义。函数体的开头，必须写函数的说明，如作用，算法等。 10.3 综合练习 本章的内容，本质上是针对一些基础的信息（三个同学的信息），构造出数据结构（List-Dict），并且添加处理数据的功能（各种函数）。 以下练习，要求你继续这个过程：在上述内容的基础上，添加新的信息和新的功能。 10.3.1 添加python课分数 问题：按学号student_id，添加同学的python课分数python_score 知识点：List和Dict的赋值，循环或者列表推导 写一个手动版 写一个函数版 Table 10.1: Python课的分数 student_id name python_score 2021001 Alex 86 2021002 Bob 59 2021003 Clare 92 思路： “一个同学”的信息，是以dict的形式保存，因此我们需要给dict添新的key-value。 回忆：List和Dict都是可变对象，你可以直接对List中的Dict中的key赋值！ def set_python_score(data, student_id, score): &#39;&#39;&#39; 设置python课的分数 &#39;&#39;&#39; pass # 这里由你完成 set_python_score(students_info,2021001,90) 10.3.2 简单统计 问题：统计python课的所有同学的平均分，以及分班级的平均分。 知识点：循环或者列表推导，累加，简单计算 手动版 函数版 def get_avg_python_score(data): &#39;&#39;&#39; 统计python课的平均分 &#39;&#39;&#39; pass # 这里由你完成 def get_avg_python_score_by_class(data, class_id): &#39;&#39;&#39; 按班级，统计python课的平均分 &#39;&#39;&#39; pass # 这里由你完成 10.3.3 由分数获得评级 问题：按照分数，给同学添加一个rank的变量。 知识点：if条件判断，List和Dict的赋值 90分+，“A” 80分+，“B” 70分+，“C” 60分+，“D” 不足60分，“E” 10.3.4 判断是否及格 问题：按照分数，给同学添加一个pass的变量。60分以上为及格 知识点：if条件判断，List和Dict的赋值，布尔值 手动版 函数版 统计及格率 10.3.5 信息输出 问题：以字符串的形式，输出某一个同学的信息（通过学号） 知识点：循环或列表推导，字符串操作。 输出的结果类似： “学号： ???? ； 姓名：??? ； 班级 ??? … …”。其中，班级信息要输出”专业 班级号”的形式，如“金融 5班” 手动版 函数版 写一个函数，输出不及格的同学的信息 def print_by_student_id(data, student_id): &#39;&#39;&#39; 打印同学信息 &#39;&#39;&#39; pass # 这里由你完成 def print_failed(data): &#39;&#39;&#39; 打印不及格的同学的信息 &#39;&#39;&#39; pass # 这里由你完成 "],["面向对象初步.html", "11 面向对象初步 11.1 概念 11.2 类 11.3 继承 11.4 重载 11.5 年级：同学的集合", " 11 面向对象初步 前面我们讲过，应该如何设计你的数据结构，如何把操作数据的方法写成函数。 现在我们讲“面向对象object oriented”，简称OO。 如果我们把处理数据的函数，和数据绑定在一起，就成了一个 11.1 概念 11.1.1 封装 数据和操作数据的方法（函数）绑定在一起，并且对外只留指定的数据接口。 这意味着，你对数据的操作，只能通过特定的接口来处理，而不能（有时候可以，但不应该），越过接口，直接处理数据。 比如：看电视。 要处理的数据是电视的信号，处理的结果是画面和声音。 操作的接口，是电视的屏幕、喇叭、按钮和遥控等。你不能（最少不应该），把电视拆开，用其他设备直接控制和处理电视的信号。 把数据和操作的方法绑定，并且把数据同外界隔离开来，称之为“封装”。 11.1.2 抽象性：类和对象 所谓的类Class：约等于类型。比如在python中，数字1,2,3,4,5是“整型”，'apple'是一个字符串，你是一个大学生等等。其中，“整形”，“字符串”，“大学生”，都可以视为某些个体的“类型”。我们称之为“类”。 所谓对象Object：就是一个具体的“个体”。比如“Alex是一个大学生”，“Bob是一个大学生”。那么“大学生”是一个类（类型），Alex和Bob则是一个具体的大学生的个体。“大学生”这个概念，把Alex和Bob作为大学生所应该具有的特征，给抽象和提取了。 一个简单的例子，说明类和对象的关系： 类Class：月饼的模子 对象Object：一个个具体月饼 11.2 类 11.2.1 简易说明 要完成我们的同学信息系统，我们首先从同学的定义开始。同学首先是个人。 我们定义一个类，Person，人。作为个同学的人的属性，我们起码要知道他们的姓名、出生日期和性别。 # 注：这是只是演示，正常情况下，我们不这么写属性，这属于“类变量” class Person: name = &#39;&#39; # 这个区间定义的变量，是所以对象公用的。 birth_year = None gender = None 这里定义了一个Person类，这个类里有3个“属性”（或理解为“类的成员变量”），即姓名、出生年份和性别。 有了“Person类”，我们可以用这个类来创建一个具体的同学（实例化一个对象），例如Alex。 s1 = Person() # 创建s1对象，这是一个个Person类的实例 # 定义一下信息。 s1.name = &#39;Alex&#39; s1.birth_year = 2000 s1.birth = &#39;female&#39; print(s1.name) ## Alex 11.2.2 someone do something 人类可以做”跑”这个动作。我们可以把跑这件事，定义为一个类的“方法”（成员函数） Python中，实例方法的第一个参数，必须是self，特质具体的对象“自己”，如“这个人”，“这个月饼”。 class Person: def run(self): &#39;&#39;&#39; 这是定义在一个类里的函数 &#39;&#39;&#39; print(&quot;running!&quot;) 我们利用Person类，可以“实例化”（动词）一个具体的人p1：可以类比用月饼的模具，做一个具体的月饼出来。 因为我们在Person里定义了Person类可以做的一个动作run，所以每一个Person的实例，例如p1,就都可以run()了 x = Person() # 用Person类，生成一个具体的对象p1 x.run() ## running! 11.2.3 正式的例子 对于任何类，我们可以定义一个“构造方法”__init__()，前后是2个下划线。其中放入我们用于初始化这个类的参数。例如，我们要用这个人的基本信息，来构造这个类。 实例方法的第一个参数都是self，指代的是“这个具体的对象”。你可以透过self引用自身的信息。 一个人，应该具有3样信息。 姓名 出生年份 性别 class Person: &#39;&#39;&#39; ‘人’类 &#39;&#39;&#39; def __init__(self, name, birth_year, gender): &#39;&#39;&#39; 构造方法。用外部信息（参数），来初始化这个类。 &#39;&#39;&#39; self.name = name self.birth_year = birth_year self.gender = gender p1 = Person(&#39;Alex&#39;,2000,&#39;female&#39;) p2 = Person(&#39;Bob&#39;,2001,&#39;male&#39;) print(p1.name) ## Alex print(p2.birth_year) ## 2001 可以这么说 p1是一个对象，是Person类的一个实例（例如，“你”是“人类”的一个实例） Person这个类，有3个属性，name，birth_year，gender 其中： self，指的是这个具体的对象自己。用月饼的例子，即self指的是具体的“这个月饼”。用同学的例子，就是p1这个人。 self.name = name，等号后面是参数中的name，即外界传入的name变量，本例中，即Person('Alex', ...)中的'Alex'。等号左侧，self.name，即这个这个具体的对象（具体的人），她的name属性。这句话的意思是，我们把这个类初始化的时候，外界传入的name变量，赋值给这个类的成员name（即self.name）。 其余赋值，也是同样的道理。我们要变量的成员，用外部的信息完成初始化。 这么做有什么意义？例如，可以做初始数据的验证。 例如：birth_year应该是个4位数的整型，而不是其他。 注：这里只是简单地抛出一个错误，并且停止初始化过程。关于“异常处理”的具体内容，这里从略。 抛出一个类型异常 raise TypeError(&#39;错误：birth_year应该是一个整形&#39;) class Person: def __init__(self, name, birth_year, gender): self.name = name if type(birth_year) != int: raise TypeError(&#39;错误：birth_year应该是一个整形&#39;) else: self.birth_year = birth_year self.gender = gender p1 = Person(&#39;Alex&#39;,&#39;2000&#39;,&#39;female&#39;) TypeError: 错误：birth_year应该是一个整形 11.2.4 方法 我们把一个类里面定义的函数（不论是操作内部还是外部的数据），称之为方法”method”。 比如，我们要打印同学的信息，我们可以写一个方法print_info。 class Person: def __init__(self, name, birth_year, gender): self.name = name if type(birth_year) != int: raise TypeError(&#39;错误：birth_year应该是一个整形&#39;) else: self.birth_year = birth_year self.gender = gender def print_info(self): print(&#39;姓名:{}，性别：{}，出生年份：{}&#39;.format(self.name,self.gender, self.birth_year)) p1 = Person(&#39;Alex&#39;,2000,&#39;female&#39;) p1.print_info() ## 姓名:Alex，性别：female，出生年份：2000 要做一个简单的计算，比如获得年龄。因为年龄每年都变化，我们可以用今年的年份，减去出生日期，那就不会错。 获得今天的日期，和年份 from datetime import date today = date.today() print(today) ## 2021-10-24 print(today.year) ## 2021 from datetime import date class Person: def __init__(self, name, birth_year, gender): self.name = name if type(birth_year) != int: raise TypeError(&#39;错误：birth_year应该是一个整形&#39;) else: self.birth_year = birth_year self.gender = gender def print_info(self): print(&#39;姓名: {}，性别: {}，出生年份:{}&#39;.format(self.name, self.gender, self.birth_year)) def get_age(self): this_year = date.today().year return this_year - self.birth_year p1 = Person(&#39;Alex&#39;, 2000, &#39;female&#39;) print(p1.get_age()) ## 21 既然如此，我们打印个人信息，就可以把年龄替代掉出生日期。 from datetime import date class Person: def __init__(self, name, birth_year, gender): self.name = name if type(birth_year) != int: raise TypeError(&#39;错误：birth_year应该是一个整形&#39;) else: self.birth_year = birth_year self.gender = gender def format_info(self): return &#39;姓名: {}，性别: {}，年龄: {}&#39;.format(self.name,self.gender,self.get_age()) def print_info(self): print(self.format_info()) def get_age(self): this_year = date.today().year return this_year - self.birth_year p1 = Person(&#39;Alex&#39;, 2000, &#39;female&#39;) p1.print_info() ## 姓名: Alex，性别: female，年龄: 21 11.2.5 练习 添加一个属性“出生省份（或直辖市）”birth_area，并修改构造方法，以添加这个变量。 添加一个方法is_from_gd()，返回该同学的是否来自广东（注意，这一返回的是一个布尔值）。 11.3 继承 我们要做一个同学信息系统，我们处理的数据对象，是一个“同学”。 “同学”是“人”。人有的属性，生日，同学都会有。 但“同学”比“人”多了一些属性，例如同学有“学号”这属性。 因此，如何表示“同学”这个类型？我们可以用“继承”：说，“同学”类，继承了“人”类，那么人有的属性和方法，同学都有，并且可以添加先属性等。 一个同学应有的信息 姓名 出生年份 性别 学号 前三个在“人”已有，其中学号是“人”类所没有的。 构造方法（初始化），依然和前面一样 定义类的时候，我们声明，Student类，“继承”自Person类，因此即使你什么代码也不写，Student也有Person类的一切功能。 class Student(Person): # 声明Student类“继承”自Person类 pass x = Student(&#39;Alex&#39;,2000,&#39;female&#39;) x.print_info() ## 姓名: Alex，性别: female，年龄: 21 我们现在处理Student类比Person类扩展的内容：student_id。 我们重写构造方法，添加一个student_id变量 def __init__(self, name, birth_year, gender, student_id)： 我们知道，在父类Person中的构造方法，已经有初始化信息处理的代码，例如检验出生年龄是否是一个整形。 我们可以调用父类的构造方法，把name, birth_year, gender传递给Person类来处理，Student类只处理新的部分，即student_id。 引用父类是super()，引用父类中的方法是super().方法名 显然，我们要用父类现成的构造方法，就是super().__init__(要传递的参数) 然后，我们只要写新的功能：检验学号，并保存 class Student(Person): def __init__(self, name, birth_year, gender, student_id): super().__init__(name, birth_year, gender) if type(student_id) != int: raise TypeError(&#39;错误：student_id应该是一个整形&#39;) else: self.student_id = student_id 当然，Student类继承自父类Person，那么Person中的方法，比如print_info()，Student类自然也是具备的， 可以直接使用 x = Student(&quot;Alex&quot;,2000,&quot;female&quot;,2021001) x.print_info() ## 姓名: Alex，性别: female，年龄: 21 11.4 重载 同学类，多了学号的信息，我们想，打印信息print_info()的时候，也要打印学号。 这就涉及到，我们要改写print_info()。改写一个父类中已有的方法，我们称之为“重载”。 一个原始的想法：我们完全重新写一个print_info()。 但在我们原始的设计中，print_info()，仅仅是打印format_info()的结果，所以其实，我们要改造的是format_info() 把学号信息，添加到其中。 print_info()会自动调用子类中定义的新的format_info() class Student(Person): def __init__(self, name, birth_year, gender, student_id): super().__init__(name, birth_year, gender) if type(student_id) != int: raise TypeError(&#39;错误：student_id应该是一个整形&#39;) else: self.student_id = student_id def format_info(self): info = &#39;学号：{}，姓名: {}，性别: {}，年龄: {}&#39;.format(self.student_id, self.name,self.gender,self.get_age()) return info x = Student(&quot;Alex&quot;,2000,&quot;female&quot;,2021001) x.print_info() ## 学号：2021001，姓名: Alex，性别: female，年龄: 21 进一步，父类Person的format_info()中做工作，也可以直接利用起来。 因此，我们可以用super().format_info()，获得Person版本的字符串信息，“姓名: xxx …” 然后，把学号信息字符串'学号：{}，'.format(self.student_id),用+号拼接到前面即可。 &#39;学号：{}，&#39;.format(self.student_id) + super().format_info() class Student(Person): def __init__(self, name, birth_year, gender, student_id): super().__init__(name, birth_year, gender) if type(student_id) != int: raise TypeError(&#39;错误：student_id应该是一个整形&#39;) else: self.student_id = student_id def format_info(self): return &#39;学号：{}，&#39;.format(self.student_id) + super().format_info() p1 = Student(&quot;Alex&quot;,2000,&quot;female&quot;,2021001) p1.print_info() ## 学号：2021001，姓名: Alex，性别: female，年龄: 21 p2 = Student(&quot;Bob&quot;,2001,&quot;male&quot;,2021002) p2.print_info() ## 学号：2021002，姓名: Bob，性别: male，年龄: 20 特别地，我们可以用Python自带的print()函数，来打印我们对象的信息。 我们把要输出的信息，写进一个__str__(self)方法中，和构造方法一样，前后2个下划线。 这样，我们调用print(x)的时候，就会打印出x.__str__()这个方法所返回中信息。 class Student(Person): def __init__(self, name, birth_year, gender, student_id): super().__init__(name, birth_year, gender) if type(student_id) != int: raise TypeError(&#39;错误：student_id应该是一个整形&#39;) else: self.student_id = student_id def format_info(self): return &#39;学号：{}，&#39;.format(self.student_id) + super().format_info() def __str__(self): return self.format_info() 我们用print_info()方法，和直接用print()函数，都可以打印出有关信息。 p1 = Student(&quot;Alex&quot;,2000,&quot;female&quot;,2021001) p1.print_info() ## 学号：2021001，姓名: Alex，性别: female，年龄: 21 print(p1) ## 学号：2021001，姓名: Alex，性别: female，年龄: 21 11.5 年级：同学的集合 我们要做一个年级类Grade，以表示全年级同学的信息。如何设计？ 储存所有同学的信息，依然可以采用列表List。 还可以保存这个年级的其他特征，例如入学年份，以及所在校区等 因为同学的数量很多，我们用入学年份和所在校区来初始化Grade对象，然后再添加同学。因此，构造方法中只有year和campus。 注意，虽然构造方法没有从外部获得同学的信息，但是依然可以在构造方法中初始化。 class Grade: &#39;&#39;&#39; 年级类，用于处理全年级同学的信息 &#39;&#39;&#39; def __init__(self, year, campus): &#39;&#39;&#39; 构造方法 &#39;&#39;&#39; self.student_list = [] #同学信息的List，初始化成空列表 self.year = year self.campus = campus 测试一下 grade_2021 = Grade(2021,&#39;白云校区&#39;) print(grade_2021.year) ## 2021 print(grade_2021.campus) ## 白云校区 先用同学的信息，创建几个Student对象。 p1 = Student(&#39;Alex&#39;,2001,&#39;female&#39;,2021001) p2 = Student(&#39;Bob&#39;,2001,&#39;male&#39;,2021002) p3 = Student(&#39;Clare&#39;,2001,&#39;female&#39;,2021003) 添加同学到年级 我们可以直接把数据添加到grade_2021的内部（虽然一般不建议如此） grade_2021.student_list.append(p1) grade_2021.student_list.append(p2) grade_2021.student_list.append(p3) print(grade_2021.student_list[0]) ## 学号：2021001，姓名: Alex，性别: female，年龄: 20 同意，直接操作底层数据，可能有数据错误的风险，例如重复添加同学。因此，我们考虑用写一个方法add_student来进行添加。以及一个函数，用来返回同学的数量。 class Grade: &#39;&#39;&#39; 年级类，用于处理全年级同学的信息 &#39;&#39;&#39; def __init__(self, year, campus): &#39;&#39;&#39; 构造方法 &#39;&#39;&#39; self.student_list = [] #同学信息的List，初始化成空列表 self.year = year self.campus = campus def add_student(self,student): self.student_list.append(student) def get_grade_size(self): return len(self.student_list) grade_2021 = Grade(2021, &#39;白云校区&#39;) grade_2021.add_student(p1) grade_2021.add_student(p2) grade_2021.add_student(p3) print(grade_2021.get_grade_size()) ## 3 print(grade_2021.student_list[0]) ## 学号：2021001，姓名: Alex，性别: female，年龄: 20 当然，数据验证是我们目标之一。比如，学号是不能重复的。 class Grade: &#39;&#39;&#39; 年级类，用于处理全年级同学的信息 &#39;&#39;&#39; def __init__(self, year, campus): &#39;&#39;&#39; 构造方法 &#39;&#39;&#39; self.student_list = [] #同学信息的List，初始化成空列表 self.year = year self.campus = campus def add_student(self, student): all_student_id = [s.student_id for s in self.student_list ] if student.student_id in all_student_id: raise ValueError(&quot;错误！学号重复：&quot; + student.__str__()) self.student_list.append(student) def get_grade_size(self): return len(self.student_list) 测试一下重复添加 grade_2021 = Grade(2021, &#39;白云校区&#39;) grade_2021.add_student(p1) grade_2021.add_student(p1) ValueError: 错误！学号重复：学号：2021001，姓名: Alex，性别: female，年龄: 20 添加了同学，得有查找功能 class Grade: &#39;&#39;&#39; 年级类，用于处理全年级同学的信息 &#39;&#39;&#39; def __init__(self, year, campus): &#39;&#39;&#39; 构造方法 &#39;&#39;&#39; self.student_list = [] #同学信息的List，初始化成空列表 self.year = year self.campus = campus def add_student(self, student): all_student_id = [s.student_id for s in self.student_list ] if student.student_id in all_student_id: raise ValueError(&quot;错误！学号重复：&quot; + student.__str__()) self.student_list.append(student) def get_grade_size(self): return len(self.student_list) def find_student_by_id(self,student_id): result = [s for s in self.student_list if s.student_id == student_id] if len(result) &gt; 0: return result[0] else: return None grade_2021 = Grade(2021,&#39;白云校区&#39;) grade_2021.add_student(p1) grade_2021.add_student(p2) grade_2021.add_student(p3) 找个人看看 x = grade_2021.find_student_by_id(2021001) print(x) ## 学号：2021001，姓名: Alex，性别: female，年龄: 20 x = grade_2021.find_student_by_id(2021009) print(x) ## None "],["numpy.html", "12 NumPy", " 12 NumPy 本节主要来自NumPy: the absolute basics for beginners NumPy基本上可以认为是一个速度非常快的、用起来很方便的List。 import numpy as np a = np.array([1, 2, 3, 4, 5, 6]) print(a) ## [1 2 3 4 5 6] b = np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) print(b) ## [[ 1 2 3 4] ## [ 5 6 7 8] ## [ 9 10 11 12]] print(np.zeros(2)) ## [0. 0.] "],["pandas.html", "13 Pandas", " 13 Pandas "],["综合数据处理.html", "14 综合数据处理", " 14 综合数据处理 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
