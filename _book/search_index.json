[["index.html", "写给文科生的Python入门和数据处理教程 Python for Social Scientists 1 引言 1.1 本书目标 1.2 本书不足 1.3 使用的程序和版本 1.4 把Python安装到你的电脑里", " 写给文科生的Python入门和数据处理教程 Python for Social Scientists Li Weicheng @ gpnu 2021-10-06 1 引言 本文是Python入门和数据处理教程，基于经管类本科课堂教学用的讲义，以供同学们自学和参考。 p.s. 本文使用RStudio以及R的Bookdown包写成。 1.1 本书目标 负基础Python入门 对于首次接触编程的人，可能对计算机和操作系统的有关知识（如“命令行”，“路径”等）缺乏了解。本文尽量把有关的知识都介绍到，争取做到“会打字就能学Python”。 Python数据处理 基本目标：替代Excel 进阶目标：对科研常用数据，如Wind和CSMAR数据库、CFPS和CHIP等微观调查数据、统计局数据、oTree实验数据等，按照研究要求进行清洗、剪裁、整合以及绘图，为进一步分析（如回归）制作出合适的数据集。 金融数据分析 待定：视教学情况。 1.2 本书不足 由于课时非常紧张，有很多有意义的内容不得不舍弃，包括但不限于： 函数式编程和数据流思想 面向对象编程 单元测试 作者水平有限，很多内容未必是最优做法，只能争取尽量清晰和明确。 要顾及同学们的计算机基础有高有低，有些地方不得不写得比较啰嗦。 1.3 使用的程序和版本 使用Anaconda以及附带的Spyder作为主要的编程环境 Python版本3.6或以上。（涉及Type Hints和f-string等） 1.4 把Python安装到你的电脑里 要完成任何一个编程任务，首先要借助Python现有的巨大的程序库（一般可称为库Library，或者包Package）。本课程主要针对经济类数据分析，涉及的包比较多。为了避免逐个安装，我们采用比较简单的做法，直接安装Anaconda。这是一个所谓“Python发行版”，里面包含了Python的执行程序（解释器等），以及大量的科学计算用包。一般的数据分析工作，直接安装这个即可。 下载地址：https://www.anaconda.com/products/individual#Downloads 直接百度Anaconda也能找到这个链接。按照你自己的操作系统下载 ，一般选择最新版，现在的电脑一般选择64bit的安装文件，安装过程采用默认选项即可。 "],["python程序的执行.html", "2 Python程序的执行 2.1 一个Python程序是什么 2.2 Python的交互式环境 2.3 预备知识：路径 2.4 用Python解释器来运行", " 2 Python程序的执行 2.1 一个Python程序是什么 我们所谓“写一个Python”程序，到底是在写一个什么东西？ 一般情况下，所谓一个Python程序，仅仅是一个你电脑里的纯文本文件，但扩展名是*.py，这个文件本质上一个.txt文件没什么不同，都可以用任何文本编辑器（例如你电脑里的“记事本”）打开和编辑。 我们要做的工作，就是用一个文本编辑器（当然也可以是一个集成编程环境如后面会用到的Spyder），编辑一个.py文件，然后把你要的代码写进去，用不同的方法去执行这个文件里代码。可能是在系统里一次性执行整个文件里所有代码，也可能是在一个交互环境里一步一步地执行。 2.1.1 基础知识：扩展名和文件类型 用于表示某个文件是什么类型，一般我们会看文件名的最后一个英文.以及之后的内容。 注意：这里只是泛泛而论。扩展名也是可以修改的，所以未必和实际的文件类型一致。 一个文件，其名为WINWORD.EXE，其扩展名为.exe（Window系统的文件名不区分大小写，但Mac系统的文件名严格区分大小写），则意味着这是一个“Windows系统的可执行文件”。这实际上是微软Windows版本office中的Word的主程序。我们（在windows下）常说的“运行一个程序”，就是执行一个exe文件。 一个文件，其名为鲁迅全集.txt，其扩展名为.txt，则意味着这是一个“纯文本文件”，其中的所有内容都可以视为文字，可以用任何一个文本编辑器，例如记事本，或者Word打开。 其他扩展名，如.jpg是常见的图形文件，.docx是2007版本以后的Word文档，等等等等。 2.2 Python的交互式环境 我们先采用最基本的Python的交互式环境，给大家一点运行程序的感觉。 启动Anaconda Prompt。（用Mac的同学，启动终端terminal） 我们会看到命令行窗口 输入python &lt;回车&gt;，我们可以进入python的交互式运行环境。 注意： 其中的命令提示符&gt;&gt;&gt;。三个右侧尖括号，表示我们正处于python的交互式环境中，此时我们可以执行python的语句。 同时可见Python的版本为3.9.5，一般3.7.x以上皆可。 2.2.1 简单的编程：计算1 + 2 我们依次输入（每行代码以结束） &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = 2 &gt;&gt;&gt; c = a + b &gt;&gt;&gt; print(c) 显然，1+2必然得到 3 结果大致如图 注意： 无法得到结果3，首先检查有没有输入错误（打错字）。 print(c)中的小括号，是英文括号。在语法层面上的所有符号，都是英文符号。 如果输入的代码有误，已经敲了回车，只要把正确代码的再输入一次即可。 2.2.2 上述程序中涉及的一些概念 这个涉及程序设计的几个基本概念： 变量和赋值 变量，顾名思义，一个可变的量。编程中变量的概念和代数中的x, y, z基本一样。 Python中，对变量赋值使用1个等号 “=”。 显然， 我们有3个变量，a, b和c。我们把1赋予a，2赋予b，把a + b的值赋予c。 运算符 加减乘除，以及逻辑运算如是否等于，大于，小于等，我们以后会用到。这里只用到“加法” 函数 和数学函数一样，我们调用一个函数，给这个函数传递一个参数，然后这个函数会根据这个参数做一些事情。可能是为你进行一个计算，可能修改某个变量等等，也可能什么都不做。 这里我们调用的函数是print()，这个函数的用途是把你传递给他的变量c的值打印出来。函数的调用方法是函数名与小括号。 数据分析的程序，大部分情况下可以视为由变量和函数组成。 2.2.3 退出运行环境 输入exit()，然后回车即可。 可见，exit本身也是一个函数（函数名+小括号），其调用这个函数的作用是退出Python交互式运行环境。 注意：一定要退出，以便后续的程序能执行。 此时，我们又回到了一开始的命令行（终端）环境中 可见，命令提示符现在是一个&gt;，这提示我们正处于系统的命令行环境中 可以执行系统中的命令，但不能执行python中的语句！ 要进行交互式的python编程，要首先进入Python的交互式环境中！ 2.3 预备知识：路径 2.3.1 路径Path 你的文件或者文件夹（目录），到底保存到了哪里？ 所谓路径(path)，到达某个文件或者文件夹（目录）的层级结构，每一层用一个斜杠“/”分割。 在命令行（终端）环境下，在命令提示符&gt;之前，一般会有提示你当前路径，即当前你处于哪个目录下。 例如 C:\\Users\\lee，指的就是，在你的C盘下，Users目录下，的lee目录。 注意：在你的电脑上，这里的lee会替换为你的用户名 这样，你输入的任何命令，都会对“当前路径”生效。 同样，路径既可以指向一个目录（文件夹），也可以指向一个文件。 如C:\\Users\\lee\\add.py，就指的是，在你的C盘下的Users目录下的lee目录下的一个叫add.py的文件。 2.3.2 相对路径和绝对路径 绝对路径：从根目录（windows下即一个盘符，如c盘或者d盘）开始的路径，可以确定无疑地指向某个文件或者目录。如C:\\Users\\lee\\add.py。 相对路径：不从根目录起始的路径。其指向的目的地，从你的“当前路径”开始，往下数。 假如，你的当前路径是C:\\Users，那么此时，相对路径lee\\add.py，所指向的，就是当前路径下（C:\\Users），lee目录下的add.py。这也等价于绝对路径C:\\Users\\lee\\add.py。 两者的区别：绝对路径从根目录开始，相对路径从“当前路径”开始。 2.3.3 进入某个目录 Windows命令行，和Mac的终端，有相同的命令cd &lt;路径&gt;，可以进入一个目录。 如，在终端中输入（并回车）注意这里使用的是绝对路径 cd C:/Users 则会让终端进入到 C:/Users 目录下。见提示符&gt;前方的“当前路径”已经改变为C:/Users。你现在已经位于C:/Users 目录。 尝试相对路径，在终端中输入（并回车），注意这里的lee，请替换成你的用户名。 cd lee 则会让终端进入到 C:/Users/lee 目录下。见提示符&gt;前方的“当前路径”已经改变为C:/Users/lee。你现在已经位于C:/Users/lee 目录。 其他用法包括： 进入上一级目录 cd .. 进入根目录 cd / 可以让你在命令行和终端中，定位到你想要的目录和文件。 2.3.4 用Windows图形界面获得路径 在你的windows资源管理器（俗称“我的电脑”），在任何一个文件夹中，点击地址栏 你就可以得到这个文件夹的路径，可以粘贴到命令行中。 特别注意：正反斜杠问题 在编程的语境下，反斜杠“\\”有特殊用途。因此，表示路径的时候，我们统一用（正）斜杠“/”，而不用反斜杠“\\”。 统一的写法，如C:/Users/lee 2.3.5 列目录 列目录的命令，Windows的命令行中为dir，Mac中为ls。同学们可以执行尝试。 2.4 用Python解释器来运行 当你离开交互环境，你的程序就没了。当然，我们不可能每次都把程序从头写一次。如前文所述，我们编写一个.py文件来保存我们的代码，然后利用系统中安装的Python解释器来执行它。 2.4.1 编写源代码 前面说过，python的代码文件.py是一个和.txt同样的纯文本文件，所以我们这次直接用记事本来编辑。 打开windows的记事本，把刚才的1 + 2程序写进去，按ctrl+s保存 a = 1 b = 2 c = a + b print(c) 在C盘根目录下，建立一个新的文件夹，例如“PythonClass”。 类型选择.（所有文件），文件名可以任意起，但是必须以.py结尾。例如我这里采用add.py。 保存。 注意： 如果你按此操作，那么你的PythonClass文件夹的完整路径（绝对路径）就是C:/PythonClass。而你的.py文件的完整路径，就是C:/PythonClass/add.py 如果你自行选取其他位置保存.py文件，那么路径也可以如此类推。如果实在找不到，则可见在Windows图形界面获得路径。 2.4.2 执行这个代码 确保你刚才已经退出了Python的交互环境。我们现在首先要定位到我们保存.py文件的目录，如果大家按操作运行，这个文件应该在C:/PythonClass目录下。 我们cd命令，转移到我们保存py文件的路径： 输入 (并回车) cd C:/PythonClass 此时你的命令提示符应该告诉你，现在位于C:/PythonClass目录下。 C:\\PythonClass&gt;_ 输入（并回车） python add.py 这句命令的含义是：让系统中装好的python解释器，去运行add.py这个python脚本文件。这个脚本文件就在当前目录中（或者环境变量path中的目录，现在可以忽略这一点）。 实际上，我们以用绝对路径来指向add.py，也是一样的。 python C:/PythonClass/add.py 如果一切顺利，你将会看到结果 3 而不同之处在于，我们的程序这次保留了下来，我们要继续上一次编程，我们只要打开这个py文件，继续往里写代码即可。 那如果我们既要保存代码，又要一边执行代码、一边看结果怎么办？ "],["使用spyder编程环境.html", "3 使用Spyder编程环境 3.1 界面 3.2 在Spyder中写代码 3.3 运行程序 3.4 预备知识：Python的注释（comment） 3.5 运行程序（续） 3.6 确定一个项目文件夹", " 3 使用Spyder编程环境 实际上，我们真正用python做数据分析的时候，一般会利用一个集成编程环境，例如我们本课程要用的Spyder，或者流行的PyCharm，或者jupyter notebook等等。 这些集成编辑环境，通常会把.py文件的编辑和python的交互环境结合起来，让我们一边编辑py文件的同时，一边执行代码并查看结果。数据分析完毕时，代码同时也写成了。 3.1 界面 打开Spyder Spyder默认打开了一个临时的.py文件。 左边是一个文本编辑器（回忆前面我们编辑add.py文件所用的记事本）。 文本编辑器的标签页，显示我们当前打开的文件是temp.py。如果文件名后带*号，表示这个文件修改了但尚未保存。 标签页上方，显示了当前文件temp.py的路径。显然，这是一个绝对路径，显示了从根目录开始到这个文件的完整路径。 右下角是Python的交互运行环境。这个环境叫IPython，比我们刚才运行Python交互环境要稍微先进一点，但本质上并无不同。 工具栏，我们后面再说。 3.2 在Spyder中写代码 我们在左侧的文本编辑器，把刚才的1+2程序写进去，按Ctrl+s保存一下（Mac: Cmd + s）。 3.3 运行程序 3.3.1 从头到尾运行代码 点击工具栏的运行按钮（Run File），或者按键盘的F5，我们可以把当前的.py脚本从头到尾运行一遍。 看交互式窗口，得到结果为3。 Run File，这个按钮的功能约等于我们在命令行环境下，直接运行“Python temp.py”。(注意我们正在编辑的文件是temp.py) 3.3.2 变量监视器 点击右上角一栏的Variable Explorer（变量浏览器），可以看到当前运行环境中的所有变量和他们的类型以及值（变量类型见后）。 点击交互界面上方的垃圾桶图标Remove all variables（移除所有变量），点击yes。 3.3.3 单步执行 现在找到“Run selection or current line”按钮。 这个按钮，顾名思义。如果你选择了一部分代码则，执行这部分代码。如果你没有选择代码，则执行光标所在行。执行完毕后，光标会自动移动到下一行。 让我们试一下。 点击第一行a=1，让输入光标在这一行 点击 ，或者F9 我们可以看到，这个按钮把光标所在行的代码“a = 1”，发送到了交互窗口，并执行，且光标自动下移了一行。 右上方的变量浏览器，现在自动出现了变量a 显然，如果我们连续点击，或者连按F9，我们就可以连续地、单步执行代码。每按一次，Spyder会把当前行的代码（或者你选定的代码），发送到交互窗口并执行。 打一个比方，这就像你同时打开记事本和python交互环境，一边在记事本中写代码，一边手动地拷贝粘贴到python交互环境中执行，是同样的逻辑。 这使得我们可以逐步查看每一行代码的效果，是实际工作中的常规操作之一。 3.3.4 选择执行 这个按钮也可以一次性执行你所选择的代码，这个大家可以自行尝试。 3.4 预备知识：Python的注释（comment） 先说注释。Python使用井号：#来表示注释。所谓注释，就是“给人看”的内容，而Python的解释器会直接忽略掉这部分。 注释可以出现在任何地方，注意#号只会影响同一行右边的代码，因此也可以出现在行尾。 注释往往也可以用来临时屏蔽一部分代码，只要在代码的最左侧插入一个#，那么整行代码会被Python解释器忽略。这是常用技巧。 我们尝试写几个注释，例如： 注释是对代码的说明，非常重要： 写代码时间长了，肯定会不记得自己写的内容。有时候上午写的，下午就会忘记。 多人合作的时候，要读懂彼此的代码，也必须有良好的注释。 特别地，注释是考试的给分点。你的考试程序输出了正确的结果，可以得到合格评价，同时具有良好的编写风格、合理的注释，才能得到更高分。 3.5 运行程序（续） 3.5.1 按Cell（单元格）执行 一般我们的程序，往往有一长串代码，或者连续几条语句，只是为了达到某一个特定目的。如果我们修改了某些代码，希望把整个代码块一次执行完，直接查看阶段性的结果，就可以使用cell。 可以使用特殊的注释#%%，两个#%%中间的代码，会被Spyder认为是一个cell（单元格）。光标所在的cell，会有不同颜色的背景颜色来区分。 定义好cell之后，我们可以使用工具栏中的2个按钮 第一个按钮是“Run current cell：执行这个cell”，快捷键是Ctrl + 回车。 第二个按钮是“Run current cell and go to the next one：执行这个cell，且光标移动到下一个cell”，快捷键是Shift + 回车。 按cell执行，和前述的按行执行，是我们做数据分析的时候会反复使用的按钮。 我们先新建一个“赋值的cell”，和“计算并打印的cell”，们用垃圾桶图标，先清空所有变量。 执行第一个cell，可以发现，变量a和b同时出现在变量浏览器中。这意味着这个cell内的按钮被一次性执行了。 当我们只关心一大块代码的结果，但不是太关心过程，我们就可以把这块代码划分为一个cell，随后就可以整块整块地执行。 3.5.2 显示你要的结果 使用交互窗口： 1. 我们之间在交互窗口输入这个变量名a，回车 2. 我们之间在交互窗口输入一个打印语句print(a)，回车 两者基本一样，但某些情况print可以接收参数，改变打印行为（样式等），直接输入变量名，就只能用默认的形式输出。 使用编辑器 1. 逐行执行，单独一个变量名也可以显示 2. 按cell运行，只会显示print()的结果 一般而言，使用print()，在代码中会比较“显眼”，达到顾名思义的效果，尽量使用。而如果只是想临时看一下变量的值，直接在交互窗口输入也可以。 3.6 确定一个项目文件夹 以C:/PythonClass为例。课程所有的有关文件，都会保存在这个目录下。我们称之为“工作目录Working Directory”。 也可以把工作目录建立在你习惯的位置。 为一个特定的工作建立一个特定的目录，是一个良好的习惯。 3.6.1 在Spyder中设定这个目录为工作目录 点击界面右上角的“browse a working directory”按钮，选择你刚才建立的工作目录。（本例中为C:/PythonClass） 切换到Files标签栏 把我们正在编辑的py文件，另存为到工作目录，命名为add.py。这样，在文件列表，我们会看到这个文件 注意：如果前面大家按步骤做，这里应该会覆盖掉上一节课的同名文件。 "],["变量和常用类型.html", "4 变量和常用类型 4.1 变量 4.2 数值 4.3 字符串String 4.4 布尔型Boolean 4.5 None类型 4.6 简单类型转换 4.7 Python的类型转换和类型错误", " 4 变量和常用类型 4.1 变量 前面说过，Python（或者其他编程语言）中的变量，和你数学课上的x, y, z是同类的概念。 正如前面的例子，Python使用等号=来为一个变量赋值 #%% 赋值与重新赋值 a = 1 a = 2 print(a) 假如这个一开始不存在，那么赋值的同时，也会把这个变量创造出来。 对于Python语言，这个过程（不严格地说）大致是： （绑定）Python在电脑的内存空间找了一个空地，创建了一个对象(object)，存放了1这个值，然后把a这个名字，和这个对象绑定起来。 （重绑定）当我们对变量a赋其他值的时候，如a = 2的时候，Python另外创建了一个对象，存放了2这个值，然后把a这个名字，重新绑定到这个新的对象上。 （引用）变量名，就像一个内存中的对象的标签。引用这个名字，就是引用其表示的对象。 4.1.1 删除一个变量 使用del语句 #%% 删除变量 a = 1 del a print(a) 因为变量a已经被我们删除了，所以你再次引用a的时候，Python会告诉你, NameError: name &#39;a&#39; is not defined 4.1.2 动态语言 Python是一个“动态语言”，即Python的变量的类型是在运行过程中决定，或者说可以在运行中改变：你对这个变量赋什么值，这个变量就是什么类型。 查看变量类型的函数是type() 例如 #%% 动态类型 a = 1 print(type(a)) a = &#39;apple&#39; # 这里为a赋值了一个字符串 print(type(a)) &lt;class &#39;int&#39;&gt; &lt;class &#39;str&#39;&gt; 显然，a先是一个整型int&lt;class 'int'&gt;，然后变成了一个字符串str&lt;class 'str'&gt;。 这和我们的赋值顺序是一样的。类型后面会详细说 注意：Python的变量类型是动态确定的。变量的类型不一定能从名字看出来，这是出错的一大来源。 4.1.3 变量的命名规则 4.2 数值 Python 3.x以后，数值类型有2种，整型int，和浮点型float。 顾名思义，整型可以理解为整数： #%% 整型 a = 1 print(type(a)) ## &lt;class &#39;int&#39;&gt; 而浮点型则可以理解为小数： #%% 浮点型 a = 1.23 print(type(a)) ## &lt;class &#39;float&#39;&gt; 特别地，a = 1.0是什么类型？ a = 1.0 print(type(a)) ## &lt;class &#39;float&#39;&gt; 显然，a是浮点型：只要你赋值的时候有小数点。 这可能是因为： 这个变量客观上是个小数，只是“恰好”是1而已。 或者这个数被四舍五入，比如本来是1.0000001之类。 4.2.1 数值的操作 常见的操作包括加减乘除+, -, *, /，此处不再重复。 特别地，除法永远返回浮点类型： a = 4 / 2 print(a) ## 2.0 print(type(a)) ## &lt;class &#39;float&#39;&gt; 整除是//。若除数是整型，则返回整型；若除数是浮点型，则返回浮点型 5 // 2 ## 2 5 // 2.0 ## 2.0 取余% 5 % 2 ## 1 乘方 \\(2^3\\) 2 ** 3 ## 8 4.3 字符串String 创建字符串，可以使用单引号、双引号、三单引号和三双引号。其中三引号可以多行定义字符串。 字符串：可以使用单引号、双引号 #%% 字符串 a = &#39;apple&#39; # 或者：a = &quot;apple&quot; print(a) ## apple 多行字符串：可以使用三个单引号，或者三个双引号。 a = &#39;&#39;&#39;Hello Python &#39;&#39;&#39; print(a) Hello Python 4.3.1 字符串的常用操作 连接字符串 + a = &#39;Hello&#39; b = &#39;Python&#39; print(a + b) ## HelloPython 注：可以连加：a + b + c + d 其他常用操作 a = &#39;Hello Python&#39; print(&#39;lo&#39; in a) # in： 是否存在 ## True print(a.find(&#39;th&#39;) )# find()：查找位置 ## 8 print(a.replace(&#39;Python&#39;,&#39;Bob&#39;)) # replace()：替换 ## Hello Bob print(a.lower()) # 转为小写：lower() ## hello python print(a.upper()) # 转为大写：upper() ## HELLO PYTHON print(&quot; apple pie &quot;.strip()) # 去除头尾的不可见字符（包括空格） ## apple pie 切片：截取字符串的一部分 后面讲列表List会详细介绍 4.3.2 显示特殊字符：转义字符\\ (转义字符到本章最后：2课时) “换行\\n” print(&quot;Hello\\nPython&quot;) ## Hello ## Python 显示反斜杠、单引号、双引号等等 这些字符，本身已经是Python语法的一部分，要放在字符串中显示，需要转义，即在这个符号之前加反斜杠，如你要显示双引号，则可以使用\\\"。 print(&#39;反斜杠\\\\&#39;) # 反斜杠 \\\\ ## 反斜杠\\ print(&#39;\\&quot;双引号\\&quot;&#39;) # 双引号 \\&#39; ## &quot;双引号&quot; print(&#39;\\&#39;单引号\\&#39;&#39;) # 单引号 \\&quot; ## &#39;单引号&#39; 如果一下子看不清楚，应该如何书写： 作为字符串最外侧的单引号，或者双引号，必须对称 a = &#39; &#39; 在单引号，或者双引号内，写入你要的文字 a = &#39;HelloWorld&#39; 把转义字符看成一个整体，插入其中，如\\n a = &#39;Hello\\nWorld&#39; print(a) ## Hello ## World 插入斜杠等，也是一样 4.3.3 字符串格式化 我们往往需要把一个变量插入一行字符中，例如我们想显示变量a和b的值 #%% 简单加法 a = 1 b = 2 c = a + b print(a) print(b) print(c) 会得到： 1 2 3 但问题是，你只看结果，其实分不清哪个是a，哪个是b，哪个是c。所以，我们更想要的是一句话，如 a的值是: 1 b的值是: 2 c的值是: 3 所以要用到字符串格式化，把变量和字符串混合。 print(&#39;a的值是:{}\\nb的值是:{}&#39;.format(a,b)) ## a的值是:1 ## b的值是:2 解释一下： 首先,'a的值是:{}\\nb的值是:{}'，是一个字符串对象（object），注意两边的单引号。 Str.format()，是字符串类型的一个方法（method），也可以称之为“成员函数”：函数名+小括号。 一个对象的方法，粗略地理解是：someone.do_something()，某样东西做了一件什么事。 Str.format()，这个方法即一个“字符串格式化了自己”。具体的做法，是把format()的参数，这里是a和b，按顺序填进原字符串中的大括号{}中。 5.注意，我们使用了换行符\\n 实际上，把字符串对象赋值给变量，如msg，那么msg就成了字符串类型（或者说指向了一个字符串对象），所以也可以这么做： msg = &#39;a的值是:{}\\nb的值是:{}&#39; print(msg.format(a,b)) ## a的值是:1 ## b的值是:2 还可以按参数的顺序（第一个元素是0）： msg = &#39;c的值是:{2}\\na的值是:{0}\\nb的值是:{1}&#39; print(msg.format(a,b,c)) ## c的值是:3 ## a的值是:1 ## b的值是:2 还有更简洁的办法”f-string”：需要python3.6版本或以上 变量的开头（单引号或者双引号之前），加f，形成f''，即所谓”f-string”。 这种字符串在打印的时候，python会自动把对应的变量填充进去。 在中括号里直接填变量名 msg = f&#39;a的值是:{a}\\nb的值是:{b}&#39; print(msg) ## a的值是:1 ## b的值是:2 实际上，你要在中括号里放其他python语句，例如其中做运算，也可以 msg = f&#39;a + b的值是{a + b}&#39; print(msg) ## a + b的值是3 简单的格式化：变量后加{变量名:格式} 如只显示2位小数:0.2f pi = 3.1415926535897 print(f&quot;圆周率（保留2位小数）是{pi:0.2f}&quot;) ## 圆周率（保留2位小数）是3.14 如以百分数形式显示:%，保留2位小数是:.2% z = 0.25 print(f&quot;z是{z:.2%}&quot;) ## z是25.00% 其他格式，可以问百度和谷歌，我们后面遇到也会讲。 4.4 布尔型Boolean 布尔型Boolean，也常简称为bool，逻辑关系，只有2个值：真True，或者假False（注意区分大小写） 一般用于条件判断（详细见后） a = 1 b = 2 if a &gt; b: print(&quot;a is bigger&quot;) 4.4.1 简单布尔运算 对于不熟悉编程的同学可能有点抽象。 与 and，或or，非not 与 and，简称：“所有条件同时成立”（全部条件为True，会得到True；否则为False） 如：“学号是单数”，且“坐在班级前排的同学” print(True and True) ## True print(False and True) ## False print(False and False) ## False 或or，简称：“最少有一个条件成立”（最少一个条件为True，会得到True；全部条件为False，则得到False） print(True or True) ## True print(False or True) ## True print(False or False) ## False 非not：取反 print(not True) ## False print(not False) ## True 举例： a = 1 b = 2 a &gt; b ## False (a &gt; 1) and (b &gt; 1) ## False (a &gt; 1) or (b &gt; 1) ## True not (b &lt; 2) ## True 注意：重点强调，必须留意运算符的优先级，先运算的部分要加括号！这和小学的数学运算是一样的。 4.5 None类型 空值，一切皆非。粗略地可以理解为一个“占位符”，例如一个不返回任何值的函数，以后遇到会再解释。 a = None print(a) ## None 4.6 简单类型转换 字符串和数值 字符串：可以表示词语、句子，可以拼接，组合 数字：可以运算 数字可以拼接吗？字符串可以做运算吗？ 先转换一下类型 birth = &quot;2001&quot; age = 2021 - birth print(age) TypeError: unsupported operand type(s) for -: &#39;int&#39; and &#39;str&#39; NameError: name &#39;age&#39; is not defined 一般而言，类型转换的函数，就是目标类型的名字。 把某个变量（如字符串str）转整型int，用函数int()，转为浮点是float() birth = &quot;2001&quot; age = 2021 - int(birth) print(age) ## 20 age = 2021 - float(birth) print(age) ## 20.0 显然反过来转换也是可以的，把某个变量转为字符串str() print(&#39;Your age is &#39; + str(age)) ## Your age is 20.0 布尔型 （有逻辑学基础，可以快速过） 特别地，布尔型中，True可视为1，False可视为0。 因此我们可以把数字的运算套用在布尔型上。 注意：要保持代码的清晰性，一般不建议使用布尔型进行运算，除非你很明白自己在做什么。 a = True # True可视为1 print(a + 1) ## 2 b = False # False可视为0 print(b - 1) ## -1 做条件判断的时候，0会判定为False，非0会判断为True，这个我们后面说条件语句的时候会说。 if -1: print(&#39;hello&#39;) ## hello 4.7 Python的类型转换和类型错误 Python是一个“动态类型+强类型”语言 动态类型： 变量名运行时绑定，变量名只是一个可以撕掉和重新粘贴的标签。你为某个变赋值什么类型，这个变量就是什么类型，在运行时可以随你的赋值代码而改变。 强类型： 一般情况下，Python不会为你自动转换类型（不会“隐式类型转换”）。 如一个很热门的语言JavaScript，大家现在上网看到的多数网站，其页面都是js语言写的。 在js中，一个字符”0”加一个数字1，js会自动（隐式地）把后者转换为字符串，然后进行拼接。 &quot;0&quot; + 1; // &quot;01&quot; 这其实对你的代码质量（如类型的检验）提出了更高要求，比如你的本意可能是要2个数字相加。 但这段代码会在你毫无知觉的情况下，一直运行下去，导致你可能要在无数代码执行过后，才发现问题。 在Python中，则会报错TypeError错误。 &#39;0&#39; + 1 TypeError: must be str, not int 显然，这说的是一个str，只能和另一个str相加（串联），而不能是一个int。 这个时候你应该用“显式”的类型转换。 如果看到TypeError，检查你的变量类型。 "],["常用数据结构.html", "5 常用数据结构 5.1 列表List 5.2 元组Tuple 5.3 字典Dict", " 5 常用数据结构 数据结构：是计算机中存储、组织数据的方式。（几乎是废话） 例如“新华字典”： 数据就是每一个字的解释 组织方式是按拼音，顺序排列 一个索引（目录），以供你查找数据。 Python中的Dict与之类似，后面详细解释。 5.1 列表List 一个列表List，就是把几个元素(items)，用一个固定的顺序连在一起的数据结构。列表List是一个重点，超级常用，内容比较多。 5.1.1 列表的创建 创建一个列表，可以用中括号[]，其中每一个元素用逗号分开。 为了好看，建议每个逗号后加一个空格。 #%% 列表List numbers = [1, 2, 3, 4, 5, 6] letters = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] print(numbers) ## [1, 2, 3, 4, 5, 6] print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 列表中的元素，可以混合多种类型。但一般不建议这么做。 a_list = [1, 2, 3, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;] print(a_list) ## [1, 2, 3, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 我们还可以创建空List。比如，当列表的第一个元素还没确定，而你要先行创建列表，然后再生成元素添加进去。 #%% 空列表 empty_list = [] empty_list = list() print(empty_list) ## [] 对一个字符串String 使用list()函数，可以把字符串分解成字母组成的List。这本质上就是类型转换：用类型的名字做转换函数的名字。 如果把函数名list看成是一个动词，或者可以解释成：list a string。 #%% print(list(&#39;apple&#39;)) ## [&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] 注意：实际上，list()可以用于所有类型的序列（有序列结构的其他数据），以后我们遇到回说。 特别地，如果我们转换一个多行的字符串，会发现什么？ a = &#39;&#39;&#39;hello python &#39;&#39;&#39; print(list(a)) ## [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;\\n&#39;, &#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;, &#39;\\n&#39;] 注意，换行符\\n也出现在其中。实际上，应该把换行符之类的不可见字符也看成一个真正的字符，实际上存在，但部分情况不可见而已 5.1.2 列表的元素 要引用一个列表的元素，也使用[]，其中包括元素的索引(index)，注意第一个元素的索引是0（Python和c语言一样，从0开始计数） print(numbers) ## [1, 2, 3, 4, 5, 6] print(numbers[0]) ## 1 print(numbers[3]) ## 4 可以反向引用元素，例如-1指向最后一个元素，-2指向倒数第二个，如此类推 print(numbers) ## [1, 2, 3, 4, 5, 6] print(numbers[-1]) ## 6 print(numbers[-2]) ## 5 列表中的元素是可变的。同样，用等号=对某个元素赋值即可 print(numbers) ## [1, 2, 3, 4, 5, 6] numbers[0] = 999 # 修改第一个元素的值为999 print(numbers) ## [999, 2, 3, 4, 5, 6] 添加元素 在List的最后添加元素可以用.append()。添加多个元素，可以用.extend()，注意extend使用一个list作为参数。插入元素到指定索引号.insert() letters = list(&quot;abcd&quot;) print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] letters.append(&#39;e&#39;)# 添加一个元素 print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] letters.extend([&#39;f&#39;,&#39;g&#39;]) #添加多个元素：把要添加的元素放进一个list里 print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] letters.insert(3,&quot;apple&quot;) #元素插入到指定索引的位置 print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;apple&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] 移除：移除某个元素，使用.remove()；按照索引移除del print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;apple&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] letters.remove(&#39;apple&#39;) # 如果&#39;apple&#39;不存在，会抛出错误：ValueError: list.remove(x): x not in list print(letters) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] del letters[0] print(letters) ## [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] 5.1.3 注意：List的拷贝 这部分可能有点抽象。 变量名是个标签 变量赋值，给内存中的一个数据“贴标签” 那用一个变量，给另一个变量赋值会如何？ 以一个数字来举例 a = 123 print(a) ## 123 b = a print(b) ## 123 a = 321 print(f&#39;a is {a}\\nb is {b}&#39;) ## a is 321 ## b is 123 中间发生了什么 a = 123 创建了一个整型对象，里面存放了123，把a这个名字绑定到这个对象上。 b = a 把a这个标签，所指代的对象，再贴一个标签b。这个时候,a和b都指向这个整型对象，里面存放了123。 a = 321 创建了一个新的整型对象，里面存放了321，把a这个名字，重新绑定到这个对象上。 现在 a -&gt; 321，b -&gt; 123 但List比较特殊 以letters来举例： a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] print(&#39;a is &#39;, a) ## a is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 变量a 指向 [\"a\", \"b\", \"c\", \"d\"] b = a 变量b 指向a相同的数据[\"a\", \"b\", \"c\", \"d\"] a[0] = &#39;apple&#39; print(&#39;b is &#39;, b) ## b is [&#39;apple&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 你修改了列表a的值，b的值也改变了！因为a和b一直指向同一个对象。 如果要避免这种情况，要明确地把a复制一次， a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] b = a.copy() print(f&#39;a is {a}\\nb is {b}&#39;) ## a is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] ## b is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] a[0] = &#39;apple&#39; print(f&#39;a is {a}\\nb is {b}&#39;) ## a is [&#39;apple&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] ## b is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 这样就不会互相干扰了。 总结： Number ,String,Tuple等，是“不可变类型”：修改这个变量，会创建一个对象，然后重绑定（转贴标签） List等，是“可变类型”：修改里面的值，其实是“原地修改”，导致所有指向这个数据的变量都发生改变。 要避免上述情况，请明确地复制原List一次。 5.1.4 List的切片 如何获取（或者修改）一个List中的某一段？ a = list(&#39;abcdef&#39;) print(a) ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] 截取：从第2个元素开始到第4个元素：（证券答案应该是['b', 'c', 'd'] a[起点的索引 : 终点的索引-1] 如： a[1:4]：切片起止点：包含起点（1号，即b），不包含终点（不含4号，即e） print(a[1:4]) ## [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 可以不写起点或者终点，默认是到一边的尽头 print(a[:4]) # 4号元素之前（0，1，2，3）（不包含终点） ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] print(a[3:]) # 3号元素以及之后（3，4，5）（包含起点） ## [&#39;d&#39;, &#39;e&#39;, &#39;f&#39;] 可以倒数切片： 如从倒数第二个元素开始到最后 print(a[-2:]) # 倒数第二个元素开始到最后（包含起点） ## [&#39;e&#39;, &#39;f&#39;] 从头切到倒数第二个元素（不含终点） print(a[:-2]) # 从头切到倒数第二个元素（不含终点） ## [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 切片赋值 ： 直接覆盖原理位置的值，可以不等长 a = list(&#39;abcdef&#39;) print(a[2:4]) ## [&#39;c&#39;, &#39;d&#39;] 注意：a[2:4]只有2个值，但我们替换成不等长的其他List，如替换3个值进去 a[2:4] = [&#39;x&#39;,&#39;y&#39;,&#39;z&#39;] print(a) ## [&#39;a&#39;, &#39;b&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, &#39;e&#39;, &#39;f&#39;] 这使得['c', 'd'] -&gt; ['x', 'y', 'z'] 赋予空列表，可以达到删除的效果。 a[2:5] = [] # x,y,z是2，3，4号 print(a) ## [&#39;a&#39;, &#39;b&#39;, &#39;e&#39;, &#39;f&#39;] 还可以按步长切片 a[起点:终点:步长] 步长默认为1（每个元素都取值），如果设置为2，每2个元素取一个值 a = list(&#39;abcdefgh&#39;) print(f&#39;&#39;&#39;a is {a} a[1:6] is {a[1:6]} a[1:6:2] is {a[1:6:2]} &#39;&#39;&#39;) ## a is [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] ## a[1:6] is [&#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;] ## a[1:6:2] is [&#39;b&#39;, &#39;d&#39;, &#39;f&#39;] 5.1.5 其他常用操作 原地排序.sort(),默认的排序方式是“从小到大” 注意：这个方法会改变原List的顺序 a = [5,3,4,2,1] a.sort() print(a) ## [1, 2, 3, 4, 5] 也可以逆序：从大到小 a.sort(reverse=True) print(a) ## [5, 4, 3, 2, 1] 排序sorted()， 注意：sorted()回返回一个新的、排序后的List，不会改变原List的顺序。 a = [5,3,4,2,1] print(a) ## [5, 3, 4, 2, 1] print(sorted(a)) # 打印排序的结果 ## [1, 2, 3, 4, 5] print(a) # 原list的顺序并未改变 ## [5, 3, 4, 2, 1] 也可以逆序排序（从大到小） b = [3,4,5,1,2] print(sorted(b, reverse=True)) ## [5, 4, 3, 2, 1] 统计某个元素的数量 .count() a = [1,2,2,2,3,3,5,5,5,5,5] print(a.count(3)) # a中的3有多少个？ ## 2 查找某个元素第一次出现的索引 a = list(&#39;an apple&#39;) print(a) ## [&#39;a&#39;, &#39;n&#39;, &#39; &#39;, &#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] print(a.index(&#39;p&#39;)) ## 4 获取的List的长度 题外话：从长度可以知道，最后一个元素的索引号是长度-1 a = list(&quot;apple&quot;) print(a) ## [&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;] print(len(a)) ## 5 获得最大最小值 a = [1,2,3,4,5] print(max(a)) # 如果包含不可比较大小类型，如str，会出错！ ## 5 print(min(a)) ## 1 5.2 元组Tuple 元组：同样是序列结构，可以视为“不可修改的列表”，其中的数据，一旦创建，就不可修改。 5.2.1 元组的创建 和List类似，但使用小括号创建。 注意，从打印的结果也可以看出，()表示元组，中括号[]表示列表。 a = (1,2,3,4,5) print(a) # 元组 ## (1, 2, 3, 4, 5) b = [1,2,3,4,5] print(b) ## [1, 2, 3, 4, 5] 如果元组只有1个元素，必须加一个逗号,，以避免python认为这是个运算。 a = (1,) # 正确的做法，识别成元组 print(a) ## (1,) b = (1) print(b) # 会被识别成一个数字 ## 1 也可以不用小括号，只使用逗号创建（为了维持代码的清晰和可识别，不建议这么做） a = 1,2,3,4,5 print(a) ## (1, 2, 3, 4, 5) 5.2.2 访问元组的元素 访问元组的方法和List完全一样，可以照搬。 但是“可读不可写”,不能做任何修改或删除。 a = (1,2,3,4,5) # 读取元素和获得切片等，和List完全一样 print(a[3]) ## 4 print(a[2:4]) ## (3, 4) a = (1,2,3,4,5) a[3] = 999 # 要对元组的值进行修改，会报错 TypeError: &#39;tuple&#39; object does not support item assignment 5.2.3 元组和列表的互转 List和Tuple用非常接近的结构，互相转换只要用前述的“简单类型转换”方法即可 a_list = list(&#39;apple&#39;) # str转为list a_tuple = tuple(a_list) # list转为tup;e print(a_tuple) # 注意，打印的结果是()小括号 ## (&#39;a&#39;, &#39;p&#39;, &#39;p&#39;, &#39;l&#39;, &#39;e&#39;) a_tuple = (1,2,3,4,5) # 创建一个tuple a_list = list(a_tuple) print(a_list) ## [1, 2, 3, 4, 5] 5.2.4 为什么要用tuple，不用list？ Tuple只有List的一半能力（只能读，不能改），只用List也可以完成Tuple的所有功能，那用Tuple有何意义？ List可能被意外修改，但Tuple不会 如前述，List是一个可变类型，可以有不止一个变量名指向同一个List数据。所以，使用List保存的数据，可能会在传递的过程中，在不经意间被你的某些代码所修改，比如忘记.copy()。 如果一个列表结构的数据，原则上不应该被改变，则可以采用Tuple。如果被代码意外修改，则会报错通知你。 Tuple一般会比List节约内存，但我们一般不必考虑这一点 5.3 字典Dict 和List或者Tuple类似，dict是很多数据的集合体 和List或者Tuple不同，dict中的数据不保证顺序， dict中的元素访问，是通过”键key”访问，一个key会对应一个value。 key的必须是不可变类型，如string，int，或者tuple。（tuple也可以做key） 和List一样，dict可以存放不同类型的数据 key是唯一的，如果对一个key赋予不同的值，那么新的value会替换旧的value. 这和新华字典类似： 通过这个字的拼音(即key)，找一个字的含义(value) 你一般不会通过这个字在字典中的第几个(index)来访问，虽然也不是不可以 5.3.1 创建dict 使用大括号，key:value的方式，key-value之间使用逗号分隔 {key1:value1, key2:value2, ... } 例如班级人数,一班50人，二班49人，三班30人。 这里使用class_x的字符串来做key，储存班级的人数。这个dict的作用是，可以通过班级的名称来获取班级的人数。 class_size = {&#39;class_1&#39;:50, &#39;class_2&#39;:49,&#39;class_3&#39;:39} print(class_size) ## {&#39;class_1&#39;: 50, &#39;class_2&#39;: 49, &#39;class_3&#39;: 39} 我们建立了一系列的映射，从字符串（本例中就是班级名称），到键值（本例中是班级人数的整型） \"class_1\" -&gt; 50 \"class_2\" -&gt; 49 \"class_3\" -&gt; 39 5.3.2 访问字典数据 字典数据的访问，和List或者Tuple一样，都是用中括号[]，但提供的数据的索引index，而是key（键名） # 获取一班的人数： # 一班的key是&quot;class_1&quot; print(class_size[&#39;class_1&#39;]) # 当然3班也一样 ## 50 print(class_size[&#39;class_3&#39;]) ## 39 修改其值也一样，直接赋值即可 class_size[&#39;class_3&#39;] = 40 print(class_size) ## {&#39;class_1&#39;: 50, &#39;class_2&#39;: 49, &#39;class_3&#39;: 40} 实际上，添加键值的方法就是直接赋值 例如，四班，key为class_4，人数为45，则： class_size[&#39;class_4&#39;] = 45 print(class_size) ## {&#39;class_1&#39;: 50, &#39;class_2&#39;: 49, &#39;class_3&#39;: 40, &#39;class_4&#39;: 45} 同样，删除键值的函数是del，和删除一个变量一样。 删除'class_4'。 del class_size[&#39;class_4&#39;] print(class_size) ## {&#39;class_1&#39;: 50, &#39;class_2&#39;: 49, &#39;class_3&#39;: 40} 5.3.3 获得所有键值 获得全部的key，使用.keys()方法。注意是复数，有个s。 print(class_size.keys()) ## dict_keys([&#39;class_1&#39;, &#39;class_2&#39;, &#39;class_3&#39;]) 注意，.keys()方法返回的不是一个List，所以我们一般还是转为List，便于进行其他操作。转换也是直接采用list()函数即可。 keys = list(class_size.keys()) print(keys) ## [&#39;class_1&#39;, &#39;class_2&#39;, &#39;class_3&#39;] 5.3.4 所有的value 获得全部的value，使用.values()方法。 print(class_size.values()) #同样是复数，有个s。 ## dict_values([50, 49, 40]) 同样，我们可以转换为List。 values = list(class_size.values()) print(values) ## [50, 49, 40] 5.3.5 其他操作 和List一样，dict也可以用len()函数获得数据的长度 print(len(class_size)) ## 3 5.3.6 别名与拷贝 和List一样，如果用一个dict为另一个dict赋值，那么2个变量和指向同一个数据，对其中一个数据的修改，会使得另一个变量中的数据也改变（毕竟只是同一个数据的2个名字） 要避免这一点，同样使用.copy()函数，拷贝一个dict。具体和List一样，这里不再重复。 5.3.7 不存在的key 如果我们直接读取一个不存在的key，会报错 class_size[&#39;class_9&#39;] key错误：即找不到’class_9’这key KeyError: &#39;class_9&#39; 但是，某些时候，我们想，如果key不存在，则返回一个默认值，而不要因为报错而中断程序。 这个时候可以使用.get()方法：如果key存在，则返回对应的value。如果不存在，则返回我们前面说过的None。 print(class_size.get(&#39;class_1&#39;)) # 获取一个存在的key ## 50 print(class_size.get(&#39;class_9&#39;)) # 获取一个不存在的key ## None 对于可能不存在的key，我们也可以使用自己指定的值。具体到本例，班级人数不可能是0，所以我们可以考虑用0来表示这个key（班级名称）不存在，或者你打错字了。 .get()这个方法的第二个参数，则是找不到key的时候的默认值。 print(class_size.get(&#39;class_9&#39;, 0)) ## 0 5.3.8 key是否存在 判断一个key是否存在， 也是用in。 print(&#39;class_1&#39; in class_size) # class_1是存在的 ## True print(&#39;class_9&#39; in class_size) # class_9是不存在的 ## False 5.3.9 （键-值元组） dict也可以视为一个类List的数据结构：其中每一个元素，是一个（键-值）对，即(key, value)的元组。 class_size = {&#39;class_1&#39;:50, &#39;class_2&#39;:49,&#39;class_3&#39;:39} print(class_size) ## {&#39;class_1&#39;: 50, &#39;class_2&#39;: 49, &#39;class_3&#39;: 39} 可以使用.items()这个方法，获取一个dict的所有(key, value)对。 print(class_size.items()) ## dict_items([(&#39;class_1&#39;, 50), (&#39;class_2&#39;, 49), (&#39;class_3&#39;, 39)]) 当然，我们也可以转为一个真正的List用list()函数 all_items = list(class_size.items()) print(all_items) ## [(&#39;class_1&#39;, 50), (&#39;class_2&#39;, 49), (&#39;class_3&#39;, 39)] 显然，这是3个(key, value)元组构成的List。 注意 1.最外层的中括号[]：这是一个List 2.每一个元素的小括号()：每一个元素是一个Tuple 看看第一个元素是什么？ print(all_items[0]) ## (&#39;class_1&#39;, 50) 易见，这就是一个（一班的名称, 一班的人数）组成的元组。 "],["条件与循环施工中.html", "6 条件与循环（施工中） 6.1 条件if 6.2 while循环 6.3 for循环 6.4 更多练习 6.5 循环Dict", " 6 条件与循环（施工中） 6.1 条件if 6.1.1 多行if ifelse, ifelse price = 102 if price &lt;100: print (&#39;buy&#39;) elif price &lt; 110: print (&#39;hold&#39;) elif price &lt; 120: print (&#39;think about it&#39;) else: print (&#39;sell&#39;) ## hold 6.1.2 单行if price = 70 if price&lt;80: print(&#39;buy&#39;) ## buy 6.1.3 三元表达式 price = 85 &#39;buy&#39; if (price&lt;80) else &#39;don\\&#39;t buy&#39; ## &quot;don&#39;t buy&quot; 6.1.4 练习 小明身高1.75m，体重80.5kg。请根据BMI公式（体重除以身高的平方）帮小明计算他的BMI指数，并根据BMI指数： 低于18.5：过轻 18.5-25：正常 25-28：过重 28-32：肥胖 高于32：严重肥胖 用if-elif判断并打印结果： 小提示： height = 1.75 weight = 80.5 # 计算BMI指数 # 用 if-elif 判断，并打印结果 判断闰年：从year, 判断是否为闰年? 注：能被4整除但不能被100整除的 或者 能被400整除 那么就是闰年 year = 2005 # 或者任何一年 6.1.5 嵌套if 例子：用if-else求a、b、c 3个数中最大的一个 思路： 比较a和b 1.1. 若a较大，则比较a和c 1.2. 若a较小，则比较b和c a = 4 b = 2 c = 9 if a&gt;b: if a&gt;c: max_value=a else: max_value=c else: if b&gt;c: max_value=b else: max_value=c print(f&quot;最大值是{max_value}&quot;) ## 最大值是9 6.1.6 练习 对一个变量number，判断是否能被2或者3整除 按具体的情况，请输出： “你输入的数字可以整除 2 和 3” “你输入的数字可以整除 2，但不能整除 3” “你输入的数字可以整除 3，但不能整除 2” “你输入的数字不能整除 2 和 3” 思路： 1. 先看看2 2. 再看看3 6.2 while循环 while循环比较直观，“只要条件成立，就重复执行某块代码块” 或者说，“重复执行某块代码块，直到条件不成立为止” while 判断条件(condition)： 执行语句(statements) 6.2.1 举例：打印 1到10 思想： 要把10以内的所有自然数都过一次，肯定要用循环 设计一个变量，用来做计数器，比如i 每次循环中，计数器累加1，直到10为止，停止循环 每次循环中，打印这个数 注：让变量自增的运算符号是+= 例如 i += 2即让i自增2，等价于 i = i + 2 i = 1 i += 999 print(i) ## 1000 设计一个从1到10的循环 i = 1 while i &lt;= 10: print(i) i +=1 ## 1 ## 2 ## 3 ## 4 ## 5 ## 6 ## 7 ## 8 ## 9 ## 10 6.2.2 练习 打印 1到10 中的偶数。 小提示：如何判断一个数是否是偶数？取余的操作符是% 利用循环，求1到100的累加，计算完成最后打印出来 小提示：你可以建立一个新的变量，用来存放累加的结果 6.3 for循环 for循环一般用于遍历一个可迭代对象（简单理解，就是如 List、Tuple和Dict这样具有序列结构的数据） 其作用是“对其中的每一个元素都做点什么”。 如果你要对一个List中的每一个元素都做点什么，此时就应该用for循环。 例如，我们要打印a = [1,2,3,4,5]中的每一个元素 或者说，我们要对a = [1,2,3,4,5]中的每一个元素，执行打印这个动作。 a_list = [1,2,3,4,5] for i in a_list: print(i) ## 1 ## 2 ## 3 ## 4 ## 5 解释 目标：对a = [1,2,3,4,5]中的每一个元素，执行打印这个动作。 a_list是一个列表的名字 for i in a_list:：我们把中的每一个元素，按顺序，逐个过一遍。轮到哪个元素，我们就用i来指向它。 print(i)：由上一句，i可以看作每一个元素代称，我们打印它。注意，前面由“1个缩进”。 break a = [1,2,3,4,5] for i in a: if i &lt; 4: print (i) else: print(&#39;从这里断开！&#39;) break else: print(&#39;循环完成！&#39;) ## 1 ## 2 ## 3 ## 从这里断开！ 6.3.1 range的循环 range(起点, 终点, 步长)：快速生成一个序列：惰性的（lazy）可迭代序列 range(0,10)：生成一个0 ~ 9的自然数序列（包括起点，不包括终点） range(0,10,2)：生成一个0 ~ 8的偶数序列（包括起点，不包括终点） 可以转为List，如: print(range(0,10)) ## range(0, 10) print(list(range(0,10))) ## [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 但是，range不用转换为List，也可以使用！ 如：按索引取值，或者切片(range切片会得到另一个range)等等 print(range(10,15)[2]) ## 12 print(range(10,15)[2:4]) ## range(12, 14) 也可以替代List，用在for循环中，常用于快速生成一个数字序列 for i in range (1,10,2): print (&#39;奇数是: &#39;,i) ## 奇数是: 1 ## 奇数是: 3 ## 奇数是: 5 ## 奇数是: 7 ## 奇数是: 9 6.4 更多练习 求1~100之间能被7整除，但不能同时被5整除的所有整数。For和While版本 求列表（或者元组）平均值。For和While版本 score = [70, 90, 78, 85, 97, 94, 65, 80] 进阶思考题：二分查找法 对于一个排序的List，找到某一个元素的位置 思路 找到列表的中间位置的元素 比较这个元素，和目标的大小。如果一样大，得到位置。 根据大小，把范围缩小到List前半段，或者后半段 在新的区间，回到1. 重复这个过程 a = [ 5,8,15,20,30,45,78,100,120,200 ] target = 30 6.4.1 列表推导式List Comprehension 遍历List，并进行某个操作 s = [&#39;abc&#39;,&#39;abcd&#39;,&#39;bcde&#39;,&#39;bcdee&#39;,&#39;cdefg&#39;] [x.upper() for x in s] ## [&#39;ABC&#39;, &#39;ABCD&#39;, &#39;BCDE&#39;, &#39;BCDEE&#39;, &#39;CDEFG&#39;] 遍历List，找出符合条件的值，并对其进行某个操作 old_list = [&#39;abc&#39;,&#39;abcd&#39;,&#39;bcde&#39;,&#39;bcdee&#39;,&#39;cdefg&#39;] matching = [ x.upper() for x in old_list if &#39;bcd&#39; in x ] print( matching ) ## [&#39;ABCD&#39;, &#39;BCDE&#39;, &#39;BCDEE&#39;] 6.5 循环Dict d = {&quot;x&quot;: 1, &quot;y&quot;: 2} for key in d: print(key, d[key]) ## x 1 ## y 2 "],["函数施工中.html", "7 函数（施工中） 7.1 定义一个函数 7.2 参数 7.3 变量作用域", " 7 函数（施工中） 一个函数，就是一个包装好的代码：你给它一些输入（参数），函数给你一个结果（返回值）： 比如，如果把电饭锅看成是一个函数，那么参数就是“米，水，电，时间”，你把“米，水，电，时间”给电饭锅，电饭锅返回给你一锅“米饭”。 写成代码，大概是： 米饭 = 电饭锅(米，水，电，时间) 这完全可以看成一个转换，或者映射 \\[ (米，水，电，时间) \\longmapsto 米饭 \\] 我们面前已经用过的，比如求List的长度： a = [1,2,3,4,5] a_size = len(a) print(a_size) ## 5 看a_size = len(a)这个代码 len() ：函数名 len(a) ：其中a是参数，即“你提供给这个函数的东西” a_size = len(a)：会返回a的长度（元素的数量），你把这个结果放在变量a_size之中 7.1 定义一个函数 在python中 定义一个函数的关键字是def， def后，是函数名，小括号内是参数（这个函数要接收的东西），最后是冒号 函数体，要有“1个缩进” 返回关键词是return。如果函数执行完都没有遇到return，则返回none 7.1.1 例：加法函数 举一个最简单的例子，我们要写一个加法函数，其作用就是把2个变量相加。或者说，你给这个函数“传递2个参数”，这个函数会返回他们的和。 #%% 定义一个加法函数 def add(x, y): z = x + y return z 逐行解释一下 第一行： def add(x, y): 定义一个函数，由def开头 接着是你给这个函数起的名字add 名字后面是小括号，里面包含了这个函数的“参数”。这里是2个参数，命名为x和y。显然，这就是你调用这个函数的时候，要给函数的东西。 最后是冒号，不要忘记 注意：关于参数，2个参数的名字你可以自己定义，不一定是x和y。这2个参数的名字，如同一切变量名一样，最终会”指向”2个值，所以你在函数的内部，就可以用这2个名字，来引用这2个值 第二行：z = x + y 注意，前面有“1个”缩进，指示这个语句比函数本身低一级 z = x + y，一目了然。需要说明的是，函数体内的2个参数，调用的时候已经有指向的目的地了。所以不会出现类似x不存在之类的错误。 第三行：return z 前面还是“1个”缩进，这是和z = x + y同一个层级的代码。 返回使用return语句。这里把和z，返回给上一层。 定义好之后，我们可以像使用任何函数一样调用它 我们来一个很熟悉的代码。 a = 1 b = 2 c = add(a, b) print(c) ## 3 7.1.2 例：求两个数的最大值 思路： 如果x &gt; y，则返回x。 否则返回y。（x &lt;= y，此时返回y也是最大值） #%% 定义一个函数，接收两个参数，返回其最大值 def my_max(a, b): if a &gt;= b: return a # 返回a else: return b # 返回b print(my_max(3,5)) ## 5 7.1.3 例：计算圆的面积 另一个例子，已知：圆的半径是\\(r\\)，我们要计算圆的面积，公式就是\\(y = \\pi r^2\\)。 我们准备写一个函数来做这件事： 这个函数会根据我们提供的半径\\(r\\)，返回一个圆的面积给我们。 显然，这个函数必然是接受r作为参数 我们做的，是算出面积，然后返回一下 def calc_area(r): area = 3.14159 * (r ** 2) return area ] x = 5 area = calc_area(x) print(f&quot;半径为{x}的圆，其面积为{area:0.2f}&quot;) ## 半径为5的圆，其面积为78.54 7.1.4 什么也不做的函数 有时候需要先占用函数名，但是函数的内容想以后再写，此时可以写一个空函数。函数体内只需要使用pass语句。 特别地，没有return语句（例如现在这种情况），或者return语句不返回值的时候，函数会返回一个none。 def do_noting(): pass print(do_noting()) ## None 7.2 参数 7.2.1 使用参数名 把参数传递给函数，可以按参数的顺序，也可以使用参数的名称 7.2.2 例：使用参数名称传递参数 def print_info(name, age): print(&quot;姓名: &quot;, name) print(&quot;年龄: &quot;, age) print_info(&#39;alex&#39;,20) # 按参数顺序：姓名，年龄 ## 姓名: alex ## 年龄: 20 print (&quot;------------------------&quot;) ## ------------------------ print_info(age = 21, name = &quot;bob&quot;) # 按参数名，此时不用考虑参数的顺序 ## 姓名: bob ## 年龄: 21 7.2.3 默认参数 定义函数的时候，可以给某些参数定义一个默认值。 默认参数必须定义在最后。 7.2.4 例：乘方函数（n次方） def power(x, n=2): # n有默认值 return x ** n print(power(5)) # 调用函数不传递n的值，使用默认值，结果为25 ## 25 print(power(3, 3)) # 调用函数传递n的值，使用传递值，结果为27 ## 27 7.2.5 不定长参数（进阶） 函数可以接受任意多个参数，例如求最大值的函数max() print(max(4,1,5,2)) ## 5 你要写一个这样的函数，那么可创建一个新的参数，前面带一个*号。那么不在参数列表里的参数，会组成一个tuple，并且绑定带这个带*号的变量名。 # 第一个参数是class_id，从第二个参数起，不定数量个参数，都会组成一个tuple，并命名为`students`(没有*) def print_students(class_id, *students): &#39;打印班级号，和同学的姓名&#39; print(&quot;班级:&quot;,class_id) print(&quot;学生包括:&quot;, students) for s in students: # 也可以逐一打印 print (s) print_students(5 ,&quot;alex&quot;,&quot;bob&quot;,&quot;clare&quot;) ## 班级: 5 ## 学生包括: (&#39;alex&#39;, &#39;bob&#39;, &#39;clare&#39;) ## alex ## bob ## clare 7.3 变量作用域 你在函数里调用了一个变量名，python会“从里到外”找这个变量，顺序是LEGB LEGB含义解释：（暂时不用管） L-Local(function)即局部名称；函数内的名字空间 E-Enclosing function locals即函数中嵌套函数的外部；外部嵌套函数的名字空间(例如closure) G-Global(module)即全局名称；函数定义所在模块（文件）的名字空间 B-Builtin(Python)即内置名称；Python内置模块的名字空间 7.3.1 局部作用域 a = 10 # 全局变量a def func(): a = 20 # 局部变量a。在定义了局部变量a之后。后面使用a这个变量名，将会首先找到这个变量（即从里到外找） print(a) # 应该是20 func() ## 20 a = 10 # 全局变量a def func(): print(a) # 在函数内部，没有变量a，那么就往外一层找，因此会找到全局变量`a`，应该等于10 func() ## 10 注:：函数內部和外部变量重名的情况，要额外小心。因此第二个例子可能是你“忘记了在函数内部定义a”，而不是你想要“引用全局变量a”，但是因为有一个全局的变量a，所以忘记定义a这个问题可能会被隐藏。 7.3.2 全局作用域 特别地，函数内部的赋值语句，其中的变量会被python看作一个local变量，如果内部未定义，就可能出错。 a = 100 # 全局变量a def func(): a = a + 1 # a + 1这个a系统认为是局部变量，但这个函数没有局部的a print(a) # 全局变量a func() UnboundLocalError: local variable &#39;a&#39; referenced before assignment 所以，如果你明确地要用一个函数外的变量，那么可以使用global关键字 a = 100 # 全局变量a def func(): global a # 说明：a这个变量名，指向的是全局变量a a = a + 1 print(a) # 全局变量a func() ## 101 "],["函数式编程入门.html", "8 函数式编程入门 8.1 map和filter 8.2 高阶函数（进阶）（施工中）", " 8 函数式编程入门 8.1 map和filter 8.1.1 map 有一个List，a = [1,2,3,4,5]，你现在要把其中的每一个元素都乘以2，并保存在一个新的List中。用现有的知识，可以这样 建立一个空的List用来保存结果result = [] 循环a中的所有元素，并且乘以2，添加到result的末端 a = [1,2,3,4,5] print(a) ## [1, 2, 3, 4, 5] result = [] for i in a: result.append(i*2) print(result) ## [2, 4, 6, 8, 10] map函数，可以把一个函数，应用到List中的所有元素上。 def do_double(x): &#39;翻倍函数&#39; return x * 2 print(do_double(3)) ## 6 把do_dobule函数，应用到列表a中的每一个元素里。 result = map(do_double, a) # 把do_dobule函数，应用到列表a中的每一个元素里。 print(list(result)) ## [2, 4, 6, 8, 10] 也可用列表推导 result = [i * 2 for i in a] print(result) ## [2, 4, 6, 8, 10] result = [do_double(i) for i in a] print(result) ## [2, 4, 6, 8, 10] 把a里的元素，全部转换为str result = map(str, a) # 把str函数，应用到列表a中的每一个元素里。 print(list(result)) ## [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;] 8.1.2 filter 有一个List，a = [1,2,3,4,5]，你现在要选出符合特定条件的元素，例如选出其中的基数，组成一个新的List。用循环做： a = [1,2,3,4,5] result = [] for i in a: if i % 2 == 1: result.append(i) print(result) ## [1, 3, 5] 和map一样，定义一个is_odd函数，作为filter的过滤条件，应该返回布尔值(True/False)，作为是否符合条件的结果。 def is_odd(x): return x % 2 == 1 print(is_odd(3)) ## True print(is_odd(6)) ## False filter(判断函数, List) resutl = filter(is_odd, a) print(list(result)) ## [1, 3, 5] 当然，也可以用列表推导 [i for i in a if is_odd(i)] ## [1, 3, 5] 8.1.3 混合map和filter 选出a中的基数，并乘以2 map 和 filter的做法 result = list(map(do_double, filter(is_odd, a))) print(result) ## [2, 6, 10] 列表推导的做法 result = [do_double(i) for i in a if is_odd(i)] print(result) ## [2, 6, 10] 注： 多数情况下，列表推导和map/filter函数几乎可以相互替代 列表更加符合Python的“风格” 但超级巨大List时，用map/filter性能更好：map/filter是一个lazy（惰性）函数，只有在你引用其中的值时，才会把函数真正应用上去。 map/filter的结果，最后要转为list 所以 清晰性：列表推导 &gt; map/filter函数 &gt; 循环 性能：map/filter函数 &gt; 列表推导 &gt; 循环 从逻辑上来讲，应该是先有map/filer：要把一个函数应用到List中的所有元素/过滤元素，这是个基础性的需求，大多数编程语言都有做这件事的办法。我们一般把这种操作统称为map/filter。Python的列表推导，可以看成是一个Python优化版的map/filter。 8.1.4 匿名函数 lambda 使用lambda关键字，一个表达式，直接返回这个表达式的结果，不用写return。 注： 对于初学者，建议还是把具体的操作起一个可以“顾名思义”的名字。 result = map(do_double, a) print(list(result)) ## [2, 4, 6, 8, 10] result = map(lambda x:x * 2,a) print(list(result)) ## [2, 4, 6, 8, 10] 8.2 高阶函数（进阶）（施工中） 在python中，函数是一等公民（头等函数，first-class function）。 一个函数，可以和一般变量一样，绑定一个名字（函数名），也可以换一个名字（从绑定），也可以作为参数传递给另一个函数（函数作为参数传另一个函数），也可以作为一个函数的返回值（函数返回另一个函数）。 8.2.1 “函数生成器”，用参数来生成不同的函数 "],["内置函数和常用库.html", "9 内置函数和常用库", " 9 内置函数和常用库 "],["numpy.html", "10 Numpy", " 10 Numpy "],["pandas.html", "11 Pandas", " 11 Pandas "],["综合数据处理.html", "12 综合数据处理", " 12 综合数据处理 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
